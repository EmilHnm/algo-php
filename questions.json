[
    {
        "index": 1,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction sayHi() {\r\n  console.log(name);\r\n  console.log(age);\r\n  var name = \"Lydia\";\r\n  let age = 21;\r\n}\r\n\r\nsayHi();\r\n```\r\n\r\n- A: `Lydia` và `undefined`\r\n- B: `Lydia` và `ReferenceError`\r\n- C: `ReferenceError` và `21`\r\n- D: `undefined` và `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nTrong hàm chúng ta đã khai báo biến `name` với `var`. Điều đó có nghĩa là biến này sẽ được hoisted (một vùng nhớ sẽ được set up khi biến được khởi tạo) với giá trị mặc định là `undefined`, cho tới khi chúng ta thực sự định nghĩa biến đó. Trong hàm này, chúng ta chưa hề định nghĩa biến `name` tại dòng mà ta log ra, vậy nên giá trị mặc định của nó vẫn là `undefined`.\r\n\r\nCác biến được khai báo với keyword `let` (và `const`) cũng được hoisted nhưng không giống như `var`, chúng không được khởi tạo. Chúng ta sẽ không thể truy cập chúng cho tới khi chúng ta khai báo (khởi tạo) chúng. Người ta gọi đó là \"temporal dead zone\". Khi ta truy cập đến một giá trị trước khi chúng được khai báo, JavaScript sẽ throws một `ReferenceError`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 2,
        "title": "Output sẽ là gì",
        "content": "```javascript\r\nfor (var i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1);\r\n}\r\n\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1);\r\n}\r\n```\r\n\r\n- A: `0 1 2` and `0 1 2`\r\n- B: `0 1 2` and `3 3 3`\r\n- C: `3 3 3` and `0 1 2`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nBởi vì event queue trong JavaScript, hàm `setTimeout` callback sẽ được gọi _sau khi_ vòng lặp được thực hiện. Bời vì biến `i` trong vòng lặp đầu tiên được khai báo với từ khóa `var`, nên nó sẽ là một biến global. Trong suốt vòng lặp, mỗi lần chúng ta tăng giá trị của `i` lên `1`, sử dụng phép toán `++`. Cho tới khi callback `setTimeout` được gọi, giá trị của `i` đã trở thành `3` rồi.\r\n\r\nTrong vòng lặp thứ 2, biến `i` được khai báo với từ khóa `let`, có nghĩa nó là một biến block-scoped (block là những gì được viết bên trong cặp ngoặc `{ }`). Tại mỗi vòng lặp, `i` sẽ là một biến mới có một giá trị mới, và giá trị đó có scope là bên trong vòng lặp mà thôi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 3,
        "title": "Output sẽ là gì",
        "content": "```javascript\r\nconst shape = {\r\n  radius: 10,\r\n  diameter() {\r\n    return this.radius * 2;\r\n  },\r\n  perimeter: () => 2 * Math.PI * this.radius,\r\n};\r\n\r\nshape.diameter();\r\nshape.perimeter();\r\n```\r\n\r\n- A: `20` and `62.83185307179586`\r\n- B: `20` and `NaN`\r\n- C: `20` and `63`\r\n- D: `NaN` and `63`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nChú ý rằng giá trị `diameter` là một hàm thông thường, còn `perimeter` là một _arrow function_.\r\n\r\nKhông giống như hàm thông thường, với _arrow function_, biến`this` sẽ trỏ tới surrounding scope! Có nghĩa là khi chúng ta gọi `perimeter`, nó sẽ không được gọi bởi shape object, mà nó được gọi bởi object nào đó tại surrounding scope (ví dụ `window` chẳng hạn).\r\n\r\nKhi không có giá trị `radius` tại object đó, nó sẽ trả về `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 4,
        "title": "Output là gì",
        "content": "```javascript\r\n+true;\r\n!\"Lydia\";\r\n```\r\n\r\n- A: `1` and `false`\r\n- B: `false` and `NaN`\r\n- C: `false` and `false`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nPhép toán cộng `+` sẽ convert một toán hạng sang dạng number. `true` là `1`, và `false` is `0`.\r\n\r\nChuỗi `'Lydia'` là một _truthy value_. Điều chúng ta thật sự đang hỏi chính là \"có phải một giá trị truthy là falsy?\". Rõ ràng câu trả lời là `false` rồi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 5,
        "title": "Cái nào đúng",
        "content": "```javascript\r\nconst bird = {\r\n  size: \"small\",\r\n};\r\n\r\nconst mouse = {\r\n  name: \"Mickey\",\r\n  small: true,\r\n};\r\n```\r\n\r\n- A: `mouse.bird.size` không hợp lệ\r\n- B: `mouse[bird.size]` không hợp lệ\r\n- C: `mouse[bird[\"size\"]]` không hợp lệ\r\n- D: Tất cả đều hợp lệ\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nTrong JavaScript thì tất cả keys của các object đều là string (ngoại trừ khi nó là một Symbol). Dù chúng ta không viết chúng như một string, về cơ bản chúng sẽ luôn được chuyển sang dạng string.\r\n\r\nJavaScript thông dịch (hay unboxes) từng câu lệnh. Khi chúng ta sử dụng cặp dấu ngoặc `[]`, nó sẽ tìm kiếm dấu mở ngoặc đầu tiên `[`, và sẽ tiếp tục tìm kiếm cho tới khi gặp dấu đóng ngoặc `]`. Chỉ khi đó thì câu lệnh mới được thực thi.\r\n\r\n`mouse[bird.size]`: Giá trị đầu tiên `bird.size` là `\"small\"`. `mouse[\"small\"]` sẽ trả về `true`\r\n\r\nTuy nhiên, khi chúng ta sử dụng dấu chấm `.`, điều trên không còn đúng nữa. `mouse` không hề có key nào tên là `bird`, có nghĩa `mouse.bird` sẽ là `undefined`. Sau đó chúng ta gọi `size` sử dụng chấm `.`: `mouse.bird.size`. Vì `mouse.bird` là `undefined`, lời gọi sẽ trở thành `undefined.size`. Đây là một lời gọi không hợp lệ, nó sẽ throw ra một lỗi kiểu như `Cannot read property \"size\" of undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 6,
        "title": "Output là gì",
        "content": "```javascript\r\nlet c = { greeting: \"Hey!\" };\r\nlet d;\r\n\r\nd = c;\r\nc.greeting = \"Hello\";\r\nconsole.log(d.greeting);\r\n```\r\n\r\n- A: `Hello`\r\n- B: `Hey`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n- E: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nTrong JavaScript, tất cả các object sẽ được _tham chiếu_ khi chúng được gán \\_bằng_wwwww một giá trị khác.\r\n\r\nĐầu tiên, giá trị `c` có giá trị là một object. Sau đó, chúng ta gán `d` tham chiếu tới object mà `c` trỏ tới.\r\n\r\n\r\n\r\nKhi ta thay đổi giá trị của object, tất cả các biến tham chiếu cũng đều thay đổi giá trị theo.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 7,
        "title": "Output là gì",
        "content": "```javascript\r\nlet a = 3;\r\nlet b = new Number(3);\r\nlet c = 3;\r\n\r\nconsole.log(a == b);\r\nconsole.log(a === b);\r\nconsole.log(b === c);\r\n```\r\n\r\n- A: `true` `false` `true`\r\n- B: `false` `false` `true`\r\n- C: `true` `false` `false`\r\n- D: `false` `true` `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\n`new Number()` là một hàm built-in constructor. Mặc dù nó trông có vẻ giống như là một số, nhưng không phải: nó thực sự là một object với hàng tá những thông số khác nữa.\r\n\r\nKhi ta sử dụng phép so sánh `==`, nó đơn thuần chỉ kiểm tra xem 2 biến có _giá trị_ giống nhau. Chúng đều có giá trị là `3`, vậy nên phép toán đầu trả về `true`.\r\n\r\nTuy nhiên khi sử dụng phép so sánh `===`, cả _giá trị_ và _kiểu_ đều phải giống nhau. Rõ ràng: `new Number()` không phải là một số, nó là một **object**. Cả 2 phép toán sau đều trả về `false.`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 8,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Chameleon {\r\n  static colorChange(newColor) {\r\n    this.newColor = newColor;\r\n    return this.newColor;\r\n  }\r\n\r\n  constructor({ newColor = \"green\" } = {}) {\r\n    this.newColor = newColor;\r\n  }\r\n}\r\n\r\nconst freddie = new Chameleon({ newColor: \"purple\" });\r\nfreddie.colorChange(\"orange\");\r\n```\r\n\r\n- A: `orange`\r\n- B: `purple`\r\n- C: `green`\r\n- D: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nHàm `colorChange` là một hàm static (hàm tĩnh). Hàm static được thiết kế để chỉ để tồn tại ở mức class, và không thể truyền cho bất cứ instance con nào. Vì `freddie` là một instance con, hàm static này sẽ không được truyền xuống, và do đó không thể gọi được tại `freddie` instance: nó sẽ throw ra một `TypeError`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 9,
        "title": "Output là gì",
        "content": "```javascript\r\nlet greeting;\r\ngreetign = {}; \/\/ Lỗi đánh máy!\r\nconsole.log(greetign);\r\n```\r\n\r\n- A: `{}`\r\n- B: `ReferenceError: greetign is not defined`\r\n- C: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nNó sẽ log ra object `greetign`, bởi vì chúng ta vừa khởi tạo một global object! Khi chúng ta đánh máy nhầm `greeting` thành `greetign`, trình thông dịch của JS sẽ coi nó như là `global.greetign = {}` (hay `window.greetign = {}` nếu chạy trên browser).\r\n\r\nĐể tránh điều này chúng ta có thể sử dụng `\"use strict\"`. Nó sẽ đảm bảo rẳng các biến đều phải được khai báo trước khi sử dụng.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 10,
        "title": "Điều gì sẽ xảy ra khi chúng ta làm thế này",
        "content": "```javascript\r\nfunction bark() {\r\n  console.log(\"Woof!\");\r\n}\r\n\r\nbark.animal = \"dog\";\r\n```\r\n\r\n- A: Hoàn toàn không có vấn đề gì!\r\n- B: `SyntaxError`. Bạn không thể thêm thuộc tính theo cách này.\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nĐiều này là có thể với Javascript, bởi vì `function` cũng chỉ là `object` mà thôi! (Mọi primitive types đều là object)\r\n\r\nFunction là một object đặc biệt. Phần code mà bạn viết không phải là function thực tế đâu. Function ở đây chính là một object với các thuộc tính. Và các thuộc tính này có thể gọi được.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 11,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n}\r\n\r\nconst member = new Person(\"Lydia\", \"Hallie\");\r\nPerson.getFullName = function () {\r\n  return `${this.firstName} ${this.lastName}`;\r\n};\r\n\r\nconsole.log(member.getFullName());\r\n```\r\n\r\n- A: `TypeError`\r\n- B: `SyntaxError`\r\n- C: `Lydia Hallie`\r\n- D: `undefined` `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nChúng ta không thể add thêm một thuộc tính cho một constructor giống như một object thông thường. Nếu bạn muốn add thêm thuộc tính nào đó cho tất cả các object một lần, bạn phải dùng `prototype`. Trong trường hợp này cũng vậy.\r\n\r\n```js\r\nPerson.prototype.getFullName = function () {\r\n  return `${this.firstName} ${this.lastName}`;\r\n};\r\n```\r\n\r\nkhi này `member.getFullName()` sẽ hoạt động. Tại sao nên làm vậy? Hãy thử thêm chúng trực tiếp vào constructor xem sao. Không phải mọi instance `Person` đều cần phương thức này. Nó sẽ dẫn tới việc lãng phí rất nhiều bộ nhớ, khi chúng đều phải lưu trữ thuộc tính này cho mỗi instance. Thay vì thế, nếu ta chỉ thêm chúng vào `prototype`, ta sẽ chỉ tốn bộ nhớ _một lần_ mà thôi, và mọi object khác đều có thể truy cập đến nó!\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 12,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n}\r\n\r\nconst lydia = new Person(\"Lydia\", \"Hallie\");\r\nconst sarah = Person(\"Sarah\", \"Smith\");\r\n\r\nconsole.log(lydia);\r\nconsole.log(sarah);\r\n```\r\n\r\n- A: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` và `undefined`\r\n- B: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` và `Person {firstName: \"Sarah\", lastName: \"Smith\"}`\r\n- C: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` và `{}`\r\n- D:`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` và `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới `sarah`, chúng ta khai báo mà không có từ khóa `new`. Khi sử dụng `new`, nó sẽ trỏ đến một object mới mà ta vừa tạo ra. Tuy nhiên nếu ta không dùng `new` thì nó sẽ trỏ tới **global object**!\r\n\r\nChúng ta cho rằng `this.firstName` là `\"Sarah\"` và `this.lastName` là `\"Smith\"`. Tuy nhiên sự thực là chúng ta đã định nghĩa `global.firstName = 'Sarah'` và `global.lastName = 'Smith'`. Bản thân biến `sarah` vẫn là `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 13,
        "title": "3 giai đoạn của event propagation là gì",
        "content": "- A: Target > Capturing > Bubbling\r\n- B: Bubbling > Target > Capturing\r\n- C: Target > Bubbling > Capturing\r\n- D: Capturing > Target > Bubbling\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nTrong **capturing** phase, event được truyền từ các phần tử cha cho tới phần tử target. Sau khi tới được phần tử **target** thì **bubbling** sẽ bắt đầu.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 14,
        "title": "Tất cả các object đều có prototypes",
        "content": "- A: đúng\r\n- B: sai\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTất cả các object đều có prototypes, ngoại trừ **base object**. Object base có thể truy cập đến vài methods và properties, ví dụ như `.toString`. Đó là lý do tại sao chúng ta có thể sử dụng được các built-in methods trong JavaScript! Tất cả các phương thức đó đều có trong prototype. Mặc dù JavaScript không thể tìm thấy chúng trong object một cách trực tiếp, nó sẽ được truyền xuống thông qua prototype chain và xuống tới object, tại đây chúng ta có thể truy cập được nó.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 15,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nsum(1, \"2\");\r\n```\r\n\r\n- A: `NaN`\r\n- B: `TypeError`\r\n- C: `\"12\"`\r\n- D: `3`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nJavaScript là một ngôn ngữ **dynamically typed**: chúng ta không khai báo kiểu dữ liệu khi khai báo biến. Giá trị có thể bị tự động convert sang một kiểu dữ liệu khác mà ta không hề hay biết, điều này được gọi là _implicit type coercion_. **Coercion** có nghĩa là convert từ kiểu này sang kiểu khác.\r\n\r\nTrong ví dụ này, JavaScript sẽ convert số `1` sang dạng string. Mỗi khi ta cộng một số (`1`) với một string (`'2'`), số sẽ luôn được xem như là một string. Kết quả sẽ là một phép nối chuỗi giống như `\"Hello\" + \"World\"`, vậy nên `\"1\" + \"2\"` sẽ trả về là `\"12\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 16,
        "title": "Output là gì",
        "content": "```javascript\r\nlet number = 0;\r\nconsole.log(number++);\r\nconsole.log(++number);\r\nconsole.log(number);\r\n```\r\n\r\n- A: `1` `1` `2`\r\n- B: `1` `2` `2`\r\n- C: `0` `2` `2`\r\n- D: `0` `1` `2`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nKhi phép toán `++` nằm ở **đằng sau** (**postfix**):\r\n\r\n1. Trả về giá trị (trả về `0`)\r\n2. Tăng giá trị lên (number giờ là `1`)\r\n\r\nKhi phép toán `++` nằm ở **đằng trước** (**prefix**):\r\n\r\n1. Tăng giá trị lên (number giờ là `2`)\r\n2. Trả về giá trị (trả về `2`)\r\n\r\nVậy kết quả là `0 2 2`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 17,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getPersonInfo(one, two, three) {\r\n  console.log(one);\r\n  console.log(two);\r\n  console.log(three);\r\n}\r\n\r\nconst person = \"Lydia\";\r\nconst age = 21;\r\n\r\ngetPersonInfo`${person} is ${age} years old`;\r\n```\r\n\r\n- A: `\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`\r\n- B: `[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`\r\n- C: `\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nNếu bạn dùng _tagged template literals_, giá trị của đối số đầu tiên luôn luôn là một mảng các string. Những đối số còn lại sẽ lấy giá trị từ biểu thức đưa vào!\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 18,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction checkAge(data) {\r\n  if (data === { age: 18 }) {\r\n    console.log(\"You are an adult!\");\r\n  } else if (data == { age: 18 }) {\r\n    console.log(\"You are still an adult.\");\r\n  } else {\r\n    console.log(`Hmm.. You don't have an age I guess`);\r\n  }\r\n}\r\n\r\ncheckAge({ age: 18 });\r\n```\r\n\r\n- A: `You are an adult!`\r\n- B: `You are still an adult.`\r\n- C: `Hmm.. You don't have an age I guess`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nKhi test sự bằng nhau, các kiểu dữ liệu cơ bản sẽ so sánh _giá trị_ của chúng, còn object thì so sánh _tham chiếu_. JavaScript sẽ kiểm tra xem các object đó có trỏ đến những vùng nhớ giống nhau hay không.\r\n\r\nHai object chúng ta đang so sánh không có được điều đó: object đối số tham chiếu đến một vùng nhớ khác với object chúng ta dùng để kiểm tra sự bằng nhau.\r\n\r\nĐó là lý do tại sao cả `{ age: 18 } === { age: 18 }` và `{ age: 18 } == { age: 18 }` đều trả về `false`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 19,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getAge(...args) {\r\n  console.log(typeof args);\r\n}\r\n\r\ngetAge(21);\r\n```\r\n\r\n- A: `\"number\"`\r\n- B: `\"array\"`\r\n- C: `\"object\"`\r\n- D: `\"NaN\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\n_Spread operator_ (`...args`.) sẽ trả về một mảng các đối số. Mảng thực chất là một object, vậy nên `typeof args` sẽ trả về `\"object\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 20,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getAge() {\r\n  \"use strict\";\r\n  age = 21;\r\n  console.log(age);\r\n}\r\n\r\ngetAge();\r\n```\r\n\r\n- A: `21`\r\n- B: `undefined`\r\n- C: `ReferenceError`\r\n- D: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới `\"use strict\"`, chúng ta sẽ đảm bảo được rằng ta sẽ không bao giờ khai báo biến global một cách vô ý. Tại đây chúng ta chưa khai báo biến `age`, và khi dùng `\"use strict\"`, nó sẽ throw ra một _reference error_. Nếu như không dùng `\"use strict\"`, nó sẽ vẫn hoạt động, vì thuộc tính `age` sẽ được thêm vào global object.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 21,
        "title": "Giá trị của `sum` là gì",
        "content": "```javascript\r\nconst sum = eval(\"10*10+5\");\r\n```\r\n\r\n- A: `105`\r\n- B: `\"105\"`\r\n- C: `TypeError`\r\n- D: `\"10*10+5\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`eval` sẽ đánh giá đoạn code bên trong string. Nếu nó là một biểu thức, giống như trong trường hợp này, nó sẽ tính toán giá trị đó. Biểu thức là `10 * 10 + 5`, kết quả sẽ là `105`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 22,
        "title": "Biến cool_secret sẽ truy cập được trong bao lâu",
        "content": "```javascript\r\nsessionStorage.setItem(\"cool_secret\", 123);\r\n```\r\n\r\n- A: Mãi mãi, dữ liệu sẽ không bao giờ mất.\r\n- B: Khi user đóng tab lại.\r\n- C: Khi user không chỉ là đóng tab, mà đóng browser lại.\r\n- D: Khi user tắt máy tính đi.\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nDữ liệu được lưu trữ trong `sessionStorage` sẽ được xóa khi đóng _tab_.\r\n\r\nNếu chúng ta dùng `localStorage`, data sẽ được lưu trữ mãi mãi, trừ phi hàm `localStorage.clear()` được gọi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 23,
        "title": "Output là gì",
        "content": "```javascript\r\nvar num = 8;\r\nvar num = 10;\r\n\r\nconsole.log(num);\r\n```\r\n\r\n- A: `8`\r\n- B: `10`\r\n- C: `SyntaxError`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới từ khóa `var` bạn có thể khai báo bao nhiêu biến trùng tên tùy thích. Biến đó sẽ có giá trị là lần cuối khai báo.\r\n\r\nBạn không thể làm điều tương tự với `let` hay `const` vì chúng là _block-scoped_.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 24,
        "title": "Output là gì",
        "content": "```javascript\r\nconst obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\r\nconst set = new Set([1, 2, 3, 4, 5]);\r\n\r\nobj.hasOwnProperty(\"1\");\r\nobj.hasOwnProperty(1);\r\nset.has(\"1\");\r\nset.has(1);\r\n```\r\n\r\n- A: `false` `true` `false` `true`\r\n- B: `false` `true` `true` `true`\r\n- C: `true` `true` `false` `true`\r\n- D: `true` `true` `true` `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nTất cả các keys của object (ngoại trừ Symbols) về bản chất đều là string, dù chúng ta có viết chúng ra dạng string hay không. Nó là lý do tại sao `obj.hasOwnProperty('1')` cũng trả về `true`.\r\n\r\nTuy nhiên điều đó không đúng với `set`. Không hề có `'1'` trong set của chúng ta: `set.has('1')` trả về `false`. Có số `1` trong set, nên `set.has(1)` trả về `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 25,
        "title": "Output là gì",
        "content": "```javascript\r\nconst obj = { a: \"one\", b: \"two\", a: \"three\" };\r\nconsole.log(obj);\r\n```\r\n\r\n- A: `{ a: \"one\", b: \"two\" }`\r\n- B: `{ b: \"two\", a: \"three\" }`\r\n- C: `{ a: \"three\", b: \"two\" }`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nNếu chúng ta có 2 keys giống nhau, thì chúng sẽ bị replace. Nó sẽ vẫn nằm ở vị trí đầu tiên chúng được khai báo, nhưng giá trị thì sẽ là giá trị lần cuối.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 26,
        "title": "Ngữ cảnh thực thi global của JavaScript tạo ra 2 thứ cho chúng ta: global object, và từ khóa \"this\"",
        "content": "- A: đúng\r\n- B: sai\r\n- C: còn tùy\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nNgữ cảnh thực thi cơ bản chính là ngữ cảnh global: nó là thứ mà chúng ta có thể truy cập được ở bất cứ đâu trong code.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 27,
        "title": "Output là gì",
        "content": "```javascript\r\nfor (let i = 1; i < 5; i++) {\r\n  if (i === 3) continue;\r\n  console.log(i);\r\n}\r\n```\r\n\r\n- A: `1` `2`\r\n- B: `1` `2` `3`\r\n- C: `1` `2` `4`\r\n- D: `1` `3` `4`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nLệnh `continue` sẽ bỏ qua một vòng lặp nếu điều kiện của nó là `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 28,
        "title": "Output là gì",
        "content": "```javascript\r\nString.prototype.giveLydiaPizza = () => {\r\n  return \"Just give Lydia pizza already!\";\r\n};\r\n\r\nconst name = \"Lydia\";\r\n\r\nconsole.log(name.giveLydiaPizza());\r\n```\r\n\r\n- A: `\"Just give Lydia pizza already!\"`\r\n- B: `TypeError: not a function`\r\n- C: `SyntaxError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`String` là một built-in constructor, có nghĩa là chúng ta có thể thêm các thuộc tính vào đó. Ta vừa thêm vào đó một thuộc tính. Kiểu String cơ bản sẽ được convert sang dạng object bởi hàm string prototype. Vì thế nên tất cả các string object đều có thể truy cập đến hàm `giveLydiaPizza` này!\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 29,
        "title": "Output là gì",
        "content": "```javascript\r\nconst a = {};\r\nconst b = { key: \"b\" };\r\nconst c = { key: \"c\" };\r\n\r\na[b] = 123;\r\na[c] = 456;\r\n\r\nconsole.log(a[b]);\r\n```\r\n\r\n- A: `123`\r\n- B: `456`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nObject keys sẽ tự động được convert sang dạng string. Chúng ta đang set một object như là một key cho object `a`, với giá trị là `123`.\r\n\r\nTuy nhiên khi ta string hóa một object, nó sẽ trở thành `\"[object Object]\"`. Nên tại đây phép gán này thực chất chính là `a[\"object Object\"] = 123`. Phép gán tiếp theo cũng giống hệt vậy. `c` là một object khác mà chúng ta đang string hóa nó. Theo đó, `a[\"object Object\"] = 456`.\r\n\r\nCuối cùng khi gọi `a[b]`, thực chất chính là gọi `a[\"object Object\"]`. Giá trị của nó là `456`, nên trả về là `456`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 30,
        "title": "Output là gì",
        "content": "```javascript\r\nconst foo = () => console.log(\"First\");\r\nconst bar = () => setTimeout(() => console.log(\"Second\"));\r\nconst baz = () => console.log(\"Third\");\r\n\r\nbar();\r\nfoo();\r\nbaz();\r\n```\r\n\r\n- A: `First` `Second` `Third`\r\n- B: `First` `Third` `Second`\r\n- C: `Second` `First` `Third`\r\n- D: `Second` `Third` `First`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nChúng ta có một hàm `setTimeout` được gọi đầu tiên. Nên, nó sẽ được log ra cuối cùng.\r\n\r\nĐiều đó bởi vì trên browser, chúng ta không hề có runtime engine, đơn thuần chỉ có `WebAPI`. `WebAPI` cho chúng ta một hàm `setTimeout`, ta hãy ví dụ nó trên DOM.\r\n\r\nSau khi _callback_ được gửi tới WebAPI, bản thân hàm `setTimeout` (nhưng không phải callback nhé!) sẽ được đưa ra khỏi stack.\r\n\r\n\r\n\r\nGiờ đây, `foo` được gọi, và `\"First\"` được log ra.\r\n\r\n\r\n\r\n`foo` được đưa ra khỏi stack, và `baz` được gọi. `\"Third\"` được log ra.\r\n\r\n\r\n\r\nWebAPI không thể thêm thứ gì đó vào stack cho tới khi nó được sẵn sàng. Thay vào đó, nó đẩy callback function đến một nơi gọi là _queue_.\r\n\r\n\r\n\r\nĐó chính là nơi mà **event loop** làm việc. Một **event loop** sẽ quan sát stack và task queue. Nếu stack trở nên rỗng, nó sẽ lấy giá trị đầu tiên trong queue để đưa tiếp vào stack.\r\n\r\n\r\n\r\n`bar` được gọi, `\"Second\"` được log ra, và nó được đưa ra khỏi stack.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 31,
        "title": "Giá trị của event",
        "content": "```html\r\n\r\n  \r\n    Click!\r\n  \r\n\r\n```\r\n\r\n- A: Outer `div`\r\n- B: Inner `div`\r\n- C: `button`\r\n- D: Một mảng với toàn bộ các phần tử lồng nhau.\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nPhần tử sâu nhất trong các phần tử lồng nhau sẽ là target của event. Bạn có thể ngăn việc đó lại bằng cách sử dụng `event.stopPropagation`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 32,
        "title": "Khi bạn click vào đoạn văn, giá trị của output sẽ là gì",
        "content": "```html\r\n\r\n  Click here!\r\n\r\n```\r\n\r\n- A: `p` `div`\r\n- B: `div` `p`\r\n- C: `p`\r\n- D: `div`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nNếu ta click vào `p`, ta sẽ thấy hai log: `p` và `div`. Trong chuỗi event sẽ có 3 phases: capturing, target, và bubbling. Mặc định thì event handlers sẽ được thực hiện tại bubbling phase (trừ phi chúng ta khai báo `useCapture` là `true`). Chúng sẽ đi từ phần tử sâu nhất ra đến bên ngoài.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 33,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = { name: \"Lydia\" };\r\n\r\nfunction sayHi(age) {\r\n  console.log(`${this.name} is ${age}`);\r\n}\r\n\r\nsayHi.call(person, 21);\r\nsayHi.bind(person, 21);\r\n```\r\n\r\n- A: `undefined is 21` `Lydia is 21`\r\n- B: `function` `function`\r\n- C: `Lydia is 21` `Lydia is 21`\r\n- D: `Lydia is 21` `function`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nVới cả hai, chúng ta có thể đưa vào object để sử dụng từ khóa `this`. Tuy nhiên, `.call` có nghĩa là _thực hiện ngay lập tức_!\r\n\r\n`.bind.` trả về một bản _copy_ của function, với context kèm theo! Nó sẽ không thực hiện ngay lập tức.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 34,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction sayHi() {\r\n  return (() => 0)();\r\n}\r\n\r\ntypeof sayHi();\r\n```\r\n\r\n- A: `\"object\"`\r\n- B: `\"number\"`\r\n- C: `\"function\"`\r\n- D: `\"undefined\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\n`sayHi` function trả về giá trị của một _hàm gọi ngay lập tức_ (immediately invoked function - IIFE). Function này trả về `0`, kiểu dữ liệu `\"number\"`.\r\n\r\nFYI: chỉ có 7 kiểu dữ liệu built-in: `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol`, and `bigint`. `\"function\"` không phải là một kiểu, mà là objects, kiểu dữ liệu là `\"object\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 35,
        "title": "Giá trị nào trong các giá trị dưới đây là falsy",
        "content": "```javascript\r\n0;\r\nnew Number(0);\r\n(\"\");\r\n(\" \");\r\nnew Boolean(false);\r\nundefined;\r\n```\r\n\r\n- A: `0`, `''`, `undefined`\r\n- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`\r\n- C: `0`, `''`, `new Boolean(false)`, `undefined`\r\n- D: Tất cả đều là falsy\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nChỉ có 6 giá trị _falsy_:\r\n\r\n- `undefined`\r\n- `null`\r\n- `NaN`\r\n- `0`\r\n- `''` (chuỗi rỗng)\r\n- `false`\r\n\r\nFunction constructors như `new Number` và `new Boolean` đều là _truthy_.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 36,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(typeof typeof 1);\r\n```\r\n\r\n- A: `\"number\"`\r\n- B: `\"string\"`\r\n- C: `\"object\"`\r\n- D: `\"undefined\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\n`typeof 1` trả về `\"number\"`.\r\n`typeof \"number\"` trả về `\"string\"`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 37,
        "title": "Output là gì",
        "content": "```javascript\r\nconst numbers = [1, 2, 3];\r\nnumbers[10] = 11;\r\nconsole.log(numbers);\r\n```\r\n\r\n- A: `[1, 2, 3, 7 x null, 11]`\r\n- B: `[1, 2, 3, 11]`\r\n- C: `[1, 2, 3, 7 x empty, 11]`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMỗi khi chúng ta set một giá trị cho một phần tử trong mảng mà vượt quá độ dài của mảng, JavaScript sẽ tạo ra những \"empty slots\". Chúng sẽ có giá trị là `undefined`, nhưng khi ghi ra thì chúng ta sẽ thấy dạng:\r\n\r\n`[1, 2, 3, 7 x empty, 11]`\r\n\r\nphụ thuộc vào nơi mà chúng ta chạy chúng (có thể khác nhau tùy môi trường browser, node, etc.)\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 38,
        "title": "Output là gì",
        "content": "```javascript\r\n(() => {\r\n  let x, y;\r\n  try {\r\n    throw new Error();\r\n  } catch (x) {\r\n    (x = 1), (y = 2);\r\n    console.log(x);\r\n  }\r\n  console.log(x);\r\n  console.log(y);\r\n})();\r\n```\r\n\r\n- A: `1` `undefined` `2`\r\n- B: `undefined` `undefined` `undefined`\r\n- C: `1` `1` `2`\r\n- D: `1` `undefined` `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`catch` block nhận về giá trị `x`. Đây không phải là giá trị `x` mà ta khai báo với từ khóa `let` ở bên trên. Đây là biến `x` trong _block-scoped_.\r\n\r\nTiếp đó, chúng ta set giá trị của biến block-scoped này là `1`, và đồng thời cũng set giá trị cho biến `y`. Giờ đây chúng ta log ra giá trị của biến block-scoped variable `x`, bằng `1`.\r\n\r\nBên ngoài `catch` block, `x` vẫn là `undefined`, và `y` là `2`. Khi gọi `console.log(x)` bên ngoài `catch` block, nó sẽ trả về `undefined`, và `y` trả về `2`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 39,
        "title": "Mọi thứ trong JavaScript đều là",
        "content": "",
        "answers": " Đáp án: A\r\n\r\nJavaScript chỉ có primitive types và objects.\r\n\r\nPrimitive types là `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, and `symbol`.\r\n\r\nĐiểm khác nhau giữa primitive và object chính là primitives không có thuộc tính hay phương thức; tuy nhiên, chúng ta để ý rằng là `'foo'.toUpperCase()` sẽ trả về `'FOO'` mà không phải là một `TypeError`. Đó là bởi vì khi chúng ta truy cập các thuộc tính hay phương thức của một primitive như là string, JavaScript sẽ ngầm bao nó bởi một `wrapper class`, ví dụ `String`, và sau đó sẽ hủy việc bao đó ngay sau khi thực hiện xong. Mọi primitives ngoại trừ `null` và `undefine` đều hoạt động giống như vậy.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 40,
        "title": "Output là gì",
        "content": "```javascript\r\n[\r\n  [0, 1],\r\n  [2, 3],\r\n].reduce(\r\n  (acc, cur) => {\r\n    return acc.concat(cur);\r\n  },\r\n  [1, 2]\r\n);\r\n```\r\n\r\n- A: `[0, 1, 2, 3, 1, 2]`\r\n- B: `[6, 1, 2]`\r\n- C: `[1, 2, 0, 1, 2, 3]`\r\n- D: `[1, 2, 6]`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\n`[1, 2]` là giá trị khởi tạo. Đây là giá trị chúng ta bắt đầu, và cũng là giá trị đầu tiên của `acc`. Tại vòng đầu tiên, `acc` là `[1,2]`, và `cur` là `[0, 1]`. Ta nối chúng lại tạo ra `[1, 2, 0, 1]`.\r\n\r\nTiếp tục, `[1, 2, 0, 1]` là `acc` và `[2, 3]` là `cur`. Ta nối chúng lại tạo ra `[1, 2, 0, 1, 2, 3]`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 41,
        "title": "Output là gì",
        "content": "```javascript\r\n!!null;\r\n!!\"\";\r\n!!1;\r\n```\r\n\r\n- A: `false` `true` `false`\r\n- B: `false` `false` `true`\r\n- C: `false` `true` `true`\r\n- D: `true` `true` `false`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\n`null` là falsy. `!null` trả về `true`. `!true` trả về `false`.\r\n\r\n`\"\"` là falsy. `!\"\"` trả về `true`. `!true` trả về `false`.\r\n\r\n`1` là truthy. `!1` trả về `fa\u001bse`. `!false` trả về `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 42,
        "title": "Hàm `setInterval` trả về cái gì",
        "content": "```javascript\r\nsetInterval(() => console.log(\"Hi\"), 1000);\r\n```\r\n\r\n- A: một id duy nhất\r\n- B: số lượng milliseconds\r\n- C: function truyền vào\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nNó trả về một id duy nhất. Id này dùng để clear interval sau này với hàm `clearInterval()`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 43,
        "title": "Giá trị trả về là gì",
        "content": "```javascript\r\n[...\"Lydia\"];\r\n```\r\n\r\n- A: `[\"L\", \"y\", \"d\", \"i\", \"a\"]`\r\n- B: `[\"Lydia\"]`\r\n- C: `[[], \"Lydia\"]`\r\n- D: `[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nString là một _iterable_. Thế nên _spread operator_ sẽ map toàn bộ các ký tự trong chuỗi lại thành một mảng.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 44,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction* generator(i) {\r\n  yield i;\r\n  yield i * 2;\r\n}\r\n\r\nconst gen = generator(10);\r\n\r\nconsole.log(gen.next().value);\r\nconsole.log(gen.next().value);\r\n```\r\n\r\n- A: `[0, 10], [10, 20]`\r\n- B: `20, 20`\r\n- C: `10, 20`\r\n- D: `0, 10 and 10, 20`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMột hàm bình thường không thể bị dừng giữa chừng khi được gọi. Tuy nhiên một _generator_ thì khác, nó có thể \"dừng lại\" được, và sau đó nó sẽ tiếp tục từ vị trí nó dừng lại. Mỗi khi một _generator_ gặp một từ khóa `yield`, nó sẽ sinh ra giá trị ngay phía sau nó. Chú ý là _generator_ không _trả về_ giá trị, nó _sinh ra_ giá trị.\r\n\r\nĐầu tiên, chúng ta khởi tạo generator với giá trị `i` là `10`. Generator được gọi bằng cách sử dụng phương thức `next()`. Khi lần đầu gọi thì `i` vẫn là `10`. Khi nó bắt gặp từ khóa `yield`: nó sẽ sinh ra giá trị `i`. Generator sẽ được \"tạm dừng\" tại đây, và ghi ra giá trị `10`.\r\n\r\nSau đó chung ta tiếp tục gọi generator bằng cách sử dụng tiếp phương thức `next()`. Nó sẽ bắt đầu từ vị trí nó tạm dừng lúc trước, khi `i` vẫn đang là `10`. Và khi nó bắt gặp từ khóa `yield`, nó sẽ sinh ra giá trị `i * 2`. `i` là `10`, nên nó sẽ sinh ra `10 * 2`, tức `20`. Vậy kết quả cuối cùng là `10, 20`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 45,
        "title": "Giá trị trả về là gì",
        "content": "```javascript\r\nconst firstPromise = new Promise((res, rej) => {\r\n  setTimeout(res, 500, \"one\");\r\n});\r\n\r\nconst secondPromise = new Promise((res, rej) => {\r\n  setTimeout(res, 100, \"two\");\r\n});\r\n\r\nPromise.race([firstPromise, secondPromise]).then((res) => console.log(res));\r\n```\r\n\r\n- A: `\"one\"`\r\n- B: `\"two\"`\r\n- C: `\"two\" \"one\"`\r\n- D: `\"one\" \"two\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nKhi chúng ta đưa các promise vào trong một hàm `Promise.race`, nó sẽ chỉ resolves hay rejects promise _đầu tiên_ được resolves\/rejects. Với hàm `setTimeout`, chúng ta đưa vào một khoảng thời gian: 500 mili giây cho promise đầu tiên (`firstPromise`), và 100 mili giây cho promise thứ hai (`secondPromise`). Nó có nghĩa là `secondPromise` sẽ hoàn thành trước và trả về giá trị `'two'`. `res` khi này sẽ nhận giá trị `'two'` và được in ra console.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 46,
        "title": "Output là gì",
        "content": "```javascript\r\nlet person = { name: \"Lydia\" };\r\nconst members = [person];\r\nperson = null;\r\n\r\nconsole.log(members);\r\n```\r\n\r\n- A: `null`\r\n- B: `[null]`\r\n- C: `[{}]`\r\n- D: `[{ name: \"Lydia\" }]`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nĐầu tiên, chúng ta khai báo một biến `person` là một object có thuộc tính `name`.\r\n\r\n\r\n\r\nSau đó chúng ta khai báo một biến `members`. Ta set giá trị đầu tiên của mảng là giá trị của biến `person`. Khi sử dụng gán bằng, object sẽ được _tham chiếu_ tới object mà nó được gán. Khi ta gán tham chiếu từ một biến sang biến khác, ta tạo ra một bản sao của tham chiếu đó. (nên nhớ rằng đó vẫn là 2 tham chiếu hoàn toàn khác nhau!)\r\n\r\n\r\n\r\nSau đó ta set giá trị của `person` bằng `null`.\r\n\r\n\r\n\r\nChúng ta chỉ đơn thuần là thay đổi giá trị của biến `person` mà thôi, chứ không phải giá trị của phần tử đầu tiên ở trong mảng, vì chúng ta có một tham chiếu khác đến object đó. Phần tử đầu tiên của mảng `members` vẫn giữ tham chiêu đến object gốc. Do vậy, khi chúng ta in ra mảng `members`, phần tử đầu tiên sẽ vẫn in ra giá trị của objet gốc.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 47,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21,\r\n};\r\n\r\nfor (const item in person) {\r\n  console.log(item);\r\n}\r\n```\r\n\r\n- A: `{ name: \"Lydia\" }, { age: 21 }`\r\n- B: `\"name\", \"age\"`\r\n- C: `\"Lydia\", 21`\r\n- D: `[\"name\", \"Lydia\"], [\"age\", 21]`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới vòng lặp `for-in` chúng ta sẽ lặp qua tất cả các `keys` của object, trong trường hợp này là `name` và `age`. Về cơ bản, object keys là string (nếu nó không phải là Symbol). Tại mỗi vòng lặp, giá trị của `item` chính là giá trị của key hiện tại trong vòng lặp. Đầu tiên, `item` là `name`, và được in ra. Vòng lặp sau, `item` là `age`, và được in ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 48,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(3 + 4 + \"5\");\r\n```\r\n\r\n- A: `\"345\"`\r\n- B: `\"75\"`\r\n- C: `12`\r\n- D: `\"12\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nCompiler sẽ đánh giá biểu thức dựa trên độ ưu tiên giữa các phép toán trong biểu thức đó, từ đó nó sẽ tính toán hoặc trái-sang-phải hoặc phải-qua-trái. Ở đây chúng ta chỉ có một phép toán mà thôi, phép cộng: `+`. Với phép cộng, tính toán sẽ là từ trái-qua-phải.\r\n\r\nGiá trị `3 + 4` được tính toán trước. Kết quả là `7`.\r\n\r\n`7 + '5'` sẽ ra kết quả là `\"75\"` bởi xuất hiện ép kiểu tại đây. JavaScript sẽ convert `7` sang dạng string, bạn có thể xem thêm tại câu hỏi 15. Và sau đó 2 string sẽ được nối lại với nhau bởi phép toán cộng `+`. Kết quả `\"7\" + \"5\"` sẽ là `\"75\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 49,
        "title": "Giá trị của `num` là gì",
        "content": "```javascript\r\nconst num = parseInt(\"7*6\", 10);\r\n```\r\n\r\n- A: `42`\r\n- B: `\"42\"`\r\n- C: `7`\r\n- D: `NaN`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nChỉ có số đầu tiên trong chuỗi kí tự được trả về. Hệ cơ số là _hệ thập phân_ (đối số thứ 2 trong hàm chính là cơ số: hệ thập phân, hệ 16, hệ 8, hệ nhị phân, vv.), Hàm `parseInt` sẽ kiểm tra xem các ký tự trong chuỗi có đảm bảo hợp lệ hay không. Một khi chúng tìm ra ký tự không phải là ký tự hợp lệ trong hệ cơ số, nó dừng lại và bỏ qua các ký tự phía sau.\r\n\r\n`*` không phải là một số. Vậy nên nó sẽ chỉ convert ký tự `\"7\"` sang hệ thập phân là `7`. `num` sẽ có giá trị là `7`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 50,
        "title": "Output là gì",
        "content": "```javascript\r\n[1, 2, 3].map((num) => {\r\n  if (typeof num === \"number\") return;\r\n  return num * 2;\r\n});\r\n```\r\n\r\n- A: `[]`\r\n- B: `[null, null, null]`\r\n- C: `[undefined, undefined, undefined]`\r\n- D: `[ 3 x empty ]`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nKhi ta tiến hành `map` một mảng, giá trị của `num` sẽ chính là giá trị của phần tử hiện giờ trong vòng lặp. Trong trường hợp này, các phần tử đều là dạng số, tức là `typeof num === \"number\"` sẽ là `true`. Hàm `map` sẽ tạo ra một mảng mởi từ các giá trị của mảng ban đầu.\r\n\r\nTuy nhiên chúng ta không hề trả về giá trị nào cả. Khi đó, hàm số sẽ mặc định trả về `undefined`. Do đó qua mỗi vòng lặp, ta lại nhận được thêm một giá trị `undefined` nữa.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 51,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getInfo(member, year) {\r\n  member.name = \"Lydia\";\r\n  year = \"1998\";\r\n}\r\n\r\nconst person = { name: \"Sarah\" };\r\nconst birthYear = \"1997\";\r\n\r\ngetInfo(person, birthYear);\r\n\r\nconsole.log(person, birthYear);\r\n```\r\n\r\n- A: `{ name: \"Lydia\" }, \"1997\"`\r\n- B: `{ name: \"Sarah\" }, \"1998\"`\r\n- C: `{ name: \"Lydia\" }, \"1998\"`\r\n- D: `{ name: \"Sarah\" }, \"1997\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`Đối số` sẽ được đưa vào hàm dạng _tham trị_, trừ phi nó là object, khi đó nó sẽ được đưa vào hàm dạng _tham chiếu_. `birthYear` là dạng giá trị, vì nó là string chứ không phải object. Khi chúng ta đưa vào dạng giá trị, một bản sao của giá trị đó sẽ được tạo ra (xem thêm câu 46).\r\n\r\n`birthYear` trỏ đến giá trị là `\"1997\"`. Đối số `year` cũng sẽ rỏ đến giá trị `\"1997\"`, nhưng giá trị này chỉ là một bản sao của giá trị mà `birthYear` trỏ tới mà thôi, hai giá trị đó hoàn toàn khác nhau. Do đó khi ta thay đổi giá trị `year` bằng `\"1998\"`, chúng ta chỉ thay đổi giá trị của `year` mà thôi. `birthYear` sẽ vẫn giữ giá trị là `\"1997\"`.\r\n\r\n`person` là một object. Biến `member` có một tham chiếu tới cùng object mà `person` trỏ tới. Khi chúng ta thay đổi một thuộc tính của object mà `member` trỏ tới, giá trị của `person` cũng sẽ tự động thay đổi theo, vì chúng có chung tham chiếu. `name` của `person` khi này sẽ có giá trị mới là `\"Lydia\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 52,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction greeting() {\r\n  throw \"Hello world!\";\r\n}\r\n\r\nfunction sayHi() {\r\n  try {\r\n    const data = greeting();\r\n    console.log(\"It worked!\", data);\r\n  } catch (e) {\r\n    console.log(\"Oh no an error!\", e);\r\n  }\r\n}\r\n\r\nsayHi();\r\n```\r\n\r\n- A: `\"It worked! Hello world!\"`\r\n- B: `\"Oh no an error: undefined`\r\n- C: `SyntaxError: can only throw Error objects`\r\n- D: `\"Oh no an error: Hello world!`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nVới lệnh `throw`, chúng ta có thể tạo ra các errors tùy ý. Với câu lệnh đó, chúng ta có thể throw các exception. Một _exeption_ có thể là một chuỗi, một số, một boolean hoặc một object. Trong trường hợp này thì nó là chuỗi `'Hello world'`.\r\n\r\nVới lệnh `catch` chúng ta có thể xử lý những exeption được throw ra khi thực hiện `try`. Một exeption đã được throw ra: chuỗi `'Hello world'`. `e` chính là chuỗi đó và chúng ta sẽ in ra. Kết quả là `'Oh an error: Hello world'`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 53,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction Car() {\r\n  this.make = \"Lamborghini\";\r\n  return { make: \"Maserati\" };\r\n}\r\n\r\nconst myCar = new Car();\r\nconsole.log(myCar.make);\r\n```\r\n\r\n- A: `\"Lamborghini\"`\r\n- B: `\"Maserati\"`\r\n- C: `ReferenceError`\r\n- D: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nKhi chúng ta trả về một thuộc tính, giá trị của thuộc tính bằng với giá trị đã được trả về bởi lệnh _return_, chứ không phải giá trị được set trong constructor. Chúng ta trả về giá trị là `\"Maserati\"`, do đó `myCar.make` sẽ là `\"Maserati\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 54,
        "title": "Output là gì",
        "content": "```javascript\r\n(() => {\r\n  let x = (y = 10);\r\n})();\r\n\r\nconsole.log(typeof x);\r\nconsole.log(typeof y);\r\n```\r\n\r\n- A: `\"undefined\", \"number\"`\r\n- B: `\"number\", \"number\"`\r\n- C: `\"object\", \"number\"`\r\n- D: `\"number\", \"undefined\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`let x = y = 10;` chính là cách viết ngắn gọn của:\r\n\r\n```javascript\r\ny = 10;\r\nlet x = y;\r\n```\r\n\r\nKhi ta set `y` bằng `10`, thực tế chúng ta đã sử dụng biến global `y` (`window` nếu là trên browser, `global` nếu là môi trường Node).Trên browser, `window.y` sẽ là `10`.\r\n\r\nSau đó, chúng ta khai báo giá trị của `x` với giá trị của `y`, tức `10`. Tuy nhiên khi ta khai báo với từ khóa `let` biến x sẽ chỉ tồn tại trong _block scoped_; hay trong trường hợp này là `hàm thực hiện ngay lập tức` (immediately-invoked function - IIFE). Khi ta sử dụng phép toán `typeof`, `x` hoàn toàn chưa được định nghĩa: vì `x` lúc này nằm bên ngoài block nó được định nghĩa lúc trước. Nghĩa là `x` là `undefined`. Do đó `console.log(typeof x)` trả về `\"undefined\"`.\r\n\r\nTuy nhiên với `y` thì khác, ta đã có giá trị của `y` khi set `y` bằng `10`. Giá trị đó có thể truy cập được từ bất kì đâu bởi chúng là biến global. `y` được định nghĩa với kiểu là `\"number\"`. Do đó `console.log(typeof y)` trả về `\"number\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 55,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Dog {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nDog.prototype.bark = function () {\r\n  console.log(`Woof I am ${this.name}`);\r\n};\r\n\r\nconst pet = new Dog(\"Mara\");\r\n\r\npet.bark();\r\n\r\ndelete Dog.prototype.bark;\r\n\r\npet.bark();\r\n```\r\n\r\n- A: `\"Woof I am Mara\"`, `TypeError`\r\n- B: `\"Woof I am Mara\"`,`\"Woof I am Mara\"`\r\n- C: `\"Woof I am Mara\"`, `undefined`\r\n- D: `TypeError`, `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nChúng ta có thể xóa các thuộc tính khỏe object bằng từ khóa `delete`, kể cả với prototype. Khi chúng ta xóa một thuộc tính trên prototype, nó sẽ bị vô hiệu hóa hoàn toàn trong chuỗi prototype. Trong trường hợp này, hàm `bark` sẽ bị vô hiệu hóa ngay sau khi chúng ta thực hiện hàm xóa `delete Dog.prototype.bark`, tất nhiên ta vẫn có thể truy cập vào nó nhưng giá trị sẽ là `undefined`.\r\n\r\nKhi chúng ta chạy một thứ không phải là `hàm`, nó sẽ bắn ra một `TypeError`. Trong trường hợp này là `TypeError: pet.bark is not a function`, vì bản thân thuộc tính `pet.bark` là `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 56,
        "title": "Output là gì",
        "content": "```javascript\r\nconst set = new Set([1, 1, 2, 3, 4]);\r\n\r\nconsole.log(set);\r\n```\r\n\r\n- A: `[1, 1, 2, 3, 4]`\r\n- B: `[1, 2, 3, 4]`\r\n- C: `{1, 1, 2, 3, 4}`\r\n- D: `{1, 2, 3, 4}`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\n`Set` là một tập hơp các giá trị _không trùng nhau_.\r\n\r\nChúng ta đưa đầu vào là một mảng `[1, 1, 2, 3, 4]` với giá trị `1` bị trùng. Giá trị trùng đó sẽ bị loại bỏ. Kết quả là `{1, 2, 3, 4}`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 57,
        "title": "Output là gì",
        "content": "```javascript\r\n\/\/ counter.js\r\nlet counter = 10;\r\nexport default counter;\r\n```\r\n\r\n```javascript\r\n\/\/ index.js\r\nimport myCounter from \".\/counter\";\r\n\r\nmyCounter += 1;\r\n\r\nconsole.log(myCounter);\r\n```\r\n\r\n- A: `10`\r\n- B: `11`\r\n- C: `Error`\r\n- D: `NaN`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMột module khi được import sẽ là **read-only**: chúng ta sẽ không thể chỉnh sửa module đó, chỉ có bản thân module đó có thể chỉnh sửa giá trị của nó mà thôi.\r\n\r\nKhi ta thay đổi giá trị cuả `myCounter`, nó sẽ throw ra một lỗi: `myCounter` là _read-only_ và không thể thay đổi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 58,
        "title": "Output là gì",
        "content": "```javascript\r\nconst name = \"Lydia\";\r\nage = 21;\r\n\r\nconsole.log(delete name);\r\nconsole.log(delete age);\r\n```\r\n\r\n- A: `false`, `true`\r\n- B: `\"Lydia\"`, `21`\r\n- C: `true`, `true`\r\n- D: `undefined`, `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nPhép toán `delete` sẽ trả về một giá trị boolean: `true` nếu xóa thành công, `false` nếu thất bại. Tuy nhiên, nếu biến được khai báo với các từ khóa `var`, `const` hay `let` thì nó sẽ không thể bị xóa bởi phép toán `delete`.\r\n\r\nBiến `name` được khai báo với từ khóa `const`, nên nó sẽ không thể bị xóa và trả về `false`. Khi ta set `age` bằng `21`, thực tế là ta đang sử dụng biến global `age`. Ta có thể xóa sử dụng phép toán `delete`, khi này `delete age` trả về `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 59,
        "title": "Output là gì",
        "content": "```javascript\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst [y] = numbers;\r\n\r\nconsole.log(y);\r\n```\r\n\r\n- A: `[[1, 2, 3, 4, 5]]`\r\n- B: `[1, 2, 3, 4, 5]`\r\n- C: `1`\r\n- D: `[1]`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nChúng ta có thể unpack các giá trị từ mảng hoặc thuộc tính từ objects bằng phương pháp `destructuring`. Ví dụ:\r\n\r\n```javascript\r\n[a, b] = [1, 2];\r\n```\r\n\r\n\r\n\r\nGiá trị của `a` sẽ là `1`, `b` sẽ là `2`. Thực tế, câu hỏi của chúng ta đơn giản là:\r\n\r\n```javascript\r\n[y] = [1, 2, 3, 4, 5];\r\n```\r\n\r\n\r\n\r\nCó nghĩa là `y` chính là giá trị đầu tiên trong mảng, tức số `1`. Do đó khi ta in ra `y` thì sẽ là`1`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 60,
        "title": "Output là gì",
        "content": "```javascript\r\nconst user = { name: \"Lydia\", age: 21 };\r\nconst admin = { admin: true, ...user };\r\n\r\nconsole.log(admin);\r\n```\r\n\r\n- A: `{ admin: true, user: { name: \"Lydia\", age: 21 } }`\r\n- B: `{ admin: true, name: \"Lydia\", age: 21 }`\r\n- C: `{ admin: true, user: [\"Lydia\", 21] }`\r\n- D: `{ admin: true }`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTa có thể kết hợp 2 object sử dụng phép toán `spread operator` `...`. Nó cho phép ta tạo ra bản sao của từng cặp key\/values trong từng object và nối chúng lại với nhau thành một object mới. Trong trường hợp này chúng ta tạo ra các bản sao của các cặp key\/value của object `user` object, và nối chúng vào object `admin`. `admin` object khi này sẽ trở thành `{ admin: true, name: \"Lydia\", age: 21 }`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 61,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = { name: \"Lydia\" };\r\n\r\nObject.defineProperty(person, \"age\", { value: 21 });\r\n\r\nconsole.log(person);\r\nconsole.log(Object.keys(person));\r\n```\r\n\r\n- A: `{ name: \"Lydia\", age: 21 }`, `[\"name\", \"age\"]`\r\n- B: `{ name: \"Lydia\", age: 21 }`, `[\"name\"]`\r\n- C: `{ name: \"Lydia\"}`, `[\"name\", \"age\"]`\r\n- D: `{ name: \"Lydia\"}`, `[\"age\"]`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới phương thức `defineProperty`, chúng ta có thể thêm các thuộc tính mới, cũng như sửa các thuộc tính sẵn có của object. Khi chúng ta thêm thuộc tính vào object bằng `defineProperty`, chúng sẽ mặc định là thuộc tính _not enumerable_. Phương thức `Object.keys` sẽ trả về tất cả các thuộc tính _enumerable_ của object, trong trường hợp này thì chỉ có `\"name\"` mà thôi.\r\n\r\nThêm nữa, các thuộc tính được thêm bởi `defineProperty` là mặc định không thể thay đổi được. Tất nhiên ta có thể override các điều đó bằng các thuộc tính như `writable`, `configurable` và `enumerable`. Tức là `defineProperty` là một cách rất mềm dẻo để tạo ra và điều chỉnh thuộc tính của object.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 62,
        "title": "Output là gì",
        "content": "```javascript\r\nconst settings = {\r\n  username: \"lydiahallie\",\r\n  level: 19,\r\n  health: 90,\r\n};\r\n\r\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\r\nconsole.log(data);\r\n```\r\n\r\n- A: `\"{\"level\":19, \"health\":90}\"`\r\n- B: `\"{\"username\": \"lydiahallie\"}\"`\r\n- C: `\"[\"level\", \"health\"]\"`\r\n- D: `\"{\"username\": \"lydiahallie\", \"level\":19, \"health\":90}\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nĐối số thứ hai của `JSON.stringify` là _replacer_. Replacer Có thể là một hàm hoặc một mảng, nó sẽ quy định xem giá trị nào sẽ được chuỗi hóa ra sao.\r\n\r\nNếu replacer là một _mảng_, chỉ có các thuộc tính có tên trong mảng được convert thành chuỗi JSON. Trong trường hợp này, chỉ có các thuộc tính `\"level\"` và `\"health\"` được đưa vào, `\"username\"` bị loại bỏ. `data` giờ sẽ là `\"{\"level\":19, \"health\":90}\"`.\r\n\r\nNếu replacer là _function_, hàm này sẽ được gọi trên từng thuộc tính của object được chuỗi hóa. Giá trị trả về sẽ là giá trị được đưa vào chuỗi JSON. Nếu trả về `undefined`, thuộc tính này sẽ bị loại bỏ khỏi chuỗi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 63,
        "title": "Output là gì",
        "content": "```javascript\r\nlet num = 10;\r\n\r\nconst increaseNumber = () => num++;\r\nconst increasePassedNumber = (number) => number++;\r\n\r\nconst num1 = increaseNumber();\r\nconst num2 = increasePassedNumber(num1);\r\n\r\nconsole.log(num1);\r\nconsole.log(num2);\r\n```\r\n\r\n- A: `10`, `10`\r\n- B: `10`, `11`\r\n- C: `11`, `11`\r\n- D: `11`, `12`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nPhép toán `++` sẽ _trả về trước_ giá trị của toán hạng, _sau đó tăng_ giá trị của toán hạng lên. Giá trị của `num1` là `10`, vì `increaseNumber` sẽ trả về giá trị của `num`, đang là `10`, và sau đó mới tăng giá trị của `num` lên.\r\n\r\n`num2` cũng là `10`, vì chúng ta đưa `num1` vào `increasePassedNumber`. `number` bằng `10`(tức giá trị của `num1`). Cũng giống như trên, phép toán `++` sẽ _trả về trước_ giá trị của toán hạng, _sau đó tăng_ giá trị của toán hạng lên. Giá trị của `number` là `10`, do đó `num2` cũng sẽ là `10`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 64,
        "title": "Output là gì",
        "content": "```javascript\r\nconst value = { number: 10 };\r\n\r\nconst multiply = (x = { ...value }) => {\r\n  console.log((x.number *= 2));\r\n};\r\n\r\nmultiply();\r\nmultiply();\r\nmultiply(value);\r\nmultiply(value);\r\n```\r\n\r\n- A: `20`, `40`, `80`, `160`\r\n- B: `20`, `40`, `20`, `40`\r\n- C: `20`, `20`, `20`, `40`\r\n- D: `NaN`, `NaN`, `20`, `40`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nTrong ES6 thì chúng ta có thể khởi tạo tham số với giá trị mặc định. Giá trị của tham số sẽ là giá trị mặc định nếu ta không truyền gì vào hàm, hoặc khi giá trị truyền vào là `\"undefined\"`. Trong trường hợp này, ta dùng `spread operator` (toán tử mở rộng) để biến `value` thành một object mới, do đó `x` sẽ có giá trị mặc định là `{ number: 10 }`.\r\n\r\nChú ý một điều là đối số sẽ được xét giá trị tại _call time_! Có nghĩa là mỗi khi chúng ta gọi hàm, một _object mới_ sẽ được tạo ra. Chúng ta gọi hàm `multiply` hai lần mà không truyền vào đối số nào cả: `x` sẽ nhận giá trị mặc định `{ number: 10 }`. Sau đó chúng ta sẽ ghi ra giá trị là `20`.\r\n\r\nLần gọi thứ ba chúng ta truyền vào một đối số: chính là `value`. Toán tử `*=` chính là cách viết gọn của `x.number = x.number * 2`: chúng ta thay đổi giá trị của `x.number`, và ghi ra giá trị `20`.\r\n\r\nTại lần gọi thứ tư, chúng ta truyền vào `value` một lần nữa. `x.number` trước đó đã bị thay đổi thành `20`, nên `x.number *= 2` sẽ ghi ra `40`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 65,
        "title": "Output là gì",
        "content": "```javascript\r\n[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\r\n```\r\n\r\n- A: `1` `2` and `3` `3` and `6` `4`\r\n- B: `1` `2` and `2` `3` and `3` `4`\r\n- C: `1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`\r\n- D: `1` `2` and `undefined` `3` and `undefined` `4`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nĐối số đầu tiên của hàm `reduce` chính là _accumulator_ (tổng tích lũy), trong trường hợp này là `x`. Đối số thứ 2 chính là _giá trị hiện tại_, tức `y`. Với hàm reduce, ta sẽ gọi callback trên mỗi phần tử của mảng, cứ vậy cho tới khi ra đến một giá trị cuối cùng.\r\n\r\nTrong trường hợp này, chúng ta không trả về bất cứ giá trị nào cả, mà đơn thuần chỉ là ghi ra giá trị của _tổng tích lũy_ và _giá trị hiện tại_ mà thôi.\r\n\r\nGiá trị của tổng tích lũy chính là giá trị được hàm callback trả về tại vòng lặp trước đó. Nếu ta không đặt giá trị khởi tạo cho đối số trong hàm `reduce`, thì tổng tích lũy sẽ chính bằng giá trị đầu tiên tại lời gọi đầu tiên.\r\n\r\nTrong lời gọi đầu tiên, tổng tích lũy (`x`) là `1`, và giá trị hiện tại (`y`) là `2`. Chúng ta không trả về giá trị cho hàm callback, mà đơn thuần chỉ ghi chúng ta, vậy nên `1` và `2` được ghi ra.\r\n\r\nNếu ta không trả về giá trị trong một function, thì nó sẽ mặc định trả về là `undefined`. Do đó trong lời gọi tiếp theo tổng tích lũy sẽ là `undefined`, và giá trị hiện tại là `3`. `undefined` và `3` sẽ được ghi ra.\r\n\r\nTiếp tục như vậy, trong lời gọi thứ tư thì tổng tích lũy sẽ vẫn là `undefined`, giá trị hiện tại là `4`. `undefined` và `4` sẽ được ghi ra.\r\n\r\n\r\n\r\n  \r\n\r\n\r\n"
    },
    {
        "index": 66,
        "title": "Với cách nào chúng ta có thể kế thừa `Dog` class",
        "content": "```javascript\r\nclass Dog {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n};\r\n\r\nclass Labrador extends Dog {\r\n  \/\/ 1\r\n  constructor(name, size) {\r\n    this.size = size;\r\n  }\r\n  \/\/ 2\r\n  constructor(name, size) {\r\n    super(name);\r\n    this.size = size;\r\n  }\r\n  \/\/ 3\r\n  constructor(size) {\r\n    super(name);\r\n    this.size = size;\r\n  }\r\n  \/\/ 4\r\n  constructor(name, size) {\r\n    this.name = name;\r\n    this.size = size;\r\n  }\r\n\r\n};\r\n```\r\n\r\n- A: 1\r\n- B: 2\r\n- C: 3\r\n- D: 4\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTrong class dẫn xuất, ta không thể truy cập từ khóa `this` trước khi gọi `super`. Nếu bạn chạy thử, nó sẽ throw ra một `ReferenceError`, do đó 1 và 4 sẽ throw ra reference error.\r\n\r\nVới việc gọi `super`, chúng ta đã gọi hàm constructor của class cha với tham số truyền vào. Trong trường hợp này, class cha nhận `name` làm đối số trong constructor, do đó chúng cần đưa `name` vào hàm `super`.\r\n\r\n`Labrador` class nhận vào hai đối số, `name` vì nó kế thừa `Dog`, và `size` - một thuộc tính của `Labrador` class. Cả hai đều cần thiết để đưa vào trong constructor của class `Labrador`, do đó cách khởi tạo đúng là 2.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 67,
        "title": "Output là gì",
        "content": "```javascript\r\n\/\/ index.js\r\nconsole.log(\"running index.js\");\r\nimport { sum } from \".\/sum.js\";\r\nconsole.log(sum(1, 2));\r\n\r\n\/\/ sum.js\r\nconsole.log(\"running sum.js\");\r\nexport const sum = (a, b) => a + b;\r\n```\r\n\r\n- A: `running index.js`, `running sum.js`, `3`\r\n- B: `running sum.js`, `running index.js`, `3`\r\n- C: `running sum.js`, `3`, `running index.js`\r\n- D: `running index.js`, `undefined`, `running sum.js`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới `import`, tất cả các module import vào đều sẽ được _pre-parsed_ (đánh giá trước). Có nghĩa là những module được import vào sẽ được _chạy trước_, còn code trong file sẽ _chạy sau_.\r\n\r\nĐó chính là điều khác biệt giữa `require()` trong CommonJS và `import`! Với `require()`, ta có thể load các dependencies tại bất cứ khi nào ta cần. Nếu ta sử dụng `require` thay thế cho `import` thì `running index.js`, `running sum.js`, `3` sẽ được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 68,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(Number(2) === Number(2))\r\nconsole.log(Boolean(false) === Boolean(false))\r\nconsole.log(Symbol('foo') === Symbol('foo'))****\r\n```\r\n\r\n- A: `true`, `true`, `false`\r\n- B: `false`, `true`, `false`\r\n- C: `true`, `false`, `true`\r\n- D: `true`, `true`, `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nMỗi Symbol là một thứ hoàn toàn khác biệt. Giá trị truyền vào làm đối số trong Symbol chỉ đơn thuần là phần giải thích cho Symbol đó mà thôi, và nó không liên quan gì tới giá trị của Symbol đó cả. Chúng ta kiểm tra tính bằng nhau của hai Symbol hoàn toàn khác biệt: `Symbol('foo')` thứ nhất, và `Symbol('foo')` thứ hai. Mỗi giá trị đều là riêng biệt và duy nhất, nên `Symbol('foo') === Symbol('foo')` sẽ trả về `false`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 69,
        "title": "Output là gì",
        "content": "```javascript\r\nconst name = \"Lydia Hallie\";\r\nconsole.log(name.padStart(13));\r\nconsole.log(name.padStart(2));\r\n```\r\n\r\n- A: `\"Lydia Hallie\"`, `\"Lydia Hallie\"`\r\n- B: `\"           Lydia Hallie\"`, `\"  Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)\r\n- C: `\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)\r\n- D: `\"Lydia Hallie\"`, `\"Lyd\"`,\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới hàm `padStart` chúng ta có thể thêm vào khoảng trắng đằng trước mỗi chuỗi. Giá trị đưa vào trong hàm là _tổng độ dài_ của chuỗi sau khi thêm vào khoảng trắng. Chuỗi `\"Lydia Hallie\"` có độ dài là `12` nên `name.padStart(13)` sẽ thêm vào một khoảng trắng đằng trước chuỗi.\r\n\r\nNếu đối số truyền vào cho hàm `padStart` nhỏ hơn độ dài của chuỗi, không có khoảng trắng nào được thêm vào.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 70,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(\"🥑\" + \"💻\");\r\n```\r\n\r\n- A: `\"🥑💻\"`\r\n- B: `257548`\r\n- C: A string containing their code points\r\n- D: Error\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới phép toán `+`, ta có thể nối các xâu chuỗi. Trong trường hợp này, ta nối chuỗi `\"🥑\"` với chuỗi `\"💻\"`, kết quả tạo ra `\"🥑💻\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 71,
        "title": "Làm thế nào có thể ghi ra giá trị giống như trong comment khi console",
        "content": "```javascript\r\nfunction* startGame() {\r\n  const answer = yield \"Do you love JavaScript",
        "answers": " Đáp án: C\r\n\r\nMột _generator_ sẽ \"tạm dừng\" khi nhìn thấy từ khóa `yield`. Đầu tiên ra sẽ đưa ra chuỗi \"Do you love JavaScript?\", bằng cách gọi `game.next().value`.\r\n\r\nChương trình sẽ chạy từng dòng, cho tới khi nó tìm thấy từ khóa `yield`. Có một từ khóa `yield` tại dòng đầu tiên của hàm: chương trình sẽ dừng tại đâ! _Điều đó có nghĩa là biến `answer` chưa hề được định nghĩa!_\r\n\r\nKhi ta gọi `game.next(\"Yes\").value`, `yield` trước đó sẽ được thay thế bởi giá trị được truyền vào hàm `next()`, trong trường hợp này là`\"Yes\"`. Theo đó giá trị của biến `answer` giờ sẽ là `\"Yes\"`. Điều kiện if sẽ trả về `false`, và `JavaScript loves you back ❤️` sẽ được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 72,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(String.raw`Hello\\nworld`);\r\n```\r\n\r\n- A: `Hello world!`\r\n- B: `Hello` &nbsp; &nbsp; &nbsp;`world`\r\n- C: `Hello\\nworld`\r\n- D: `Hello\\n`  &nbsp; &nbsp; &nbsp;`world`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\n`String.raw` trả về chuỗi nguyên bản, các ký tự (`\\n`, `\\v`, `\\t` etc.) sẽ vẫn là nguyên bản và không biến thành xuống dòng hay khoảng trắng! Nếu ta không để là chuỗi nguyên bản, sẽ có trường hợp xảy ra lỗi không mong muốn, ví dụ với đường dẫn:\r\n\r\n`` const path = `C:\\Documents\\Projects\\table.html` ``\r\n\r\nSẽ cho ta chuỗi là:\r\n\r\n`\"C:DocumentsProjects able.html\"`\r\n\r\nVới `String.raw`, nó sẽ trả về là:\r\n\r\n`C:\\Documents\\Projects\\table.html`\r\n\r\nDo đó, trong trường hợp này `Hello\\nworld` sẽ được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 73,
        "title": "Output là gì",
        "content": "```javascript\r\nasync function getData() {\r\n  return await Promise.resolve(\"I made it!\");\r\n}\r\n\r\nconst data = getData();\r\nconsole.log(data);\r\n```\r\n\r\n- A: `\"I made it!\"`\r\n- B: `Promise {: \"I made it!\"}`\r\n- C: `Promise {}`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMột hàm `async` luôn luôn trả về một `promise`. `await` sẽ chờ cho tới khi promise đó được hoàn thành: một pending promise sẽ được trả về khi ta gọi `getData()` bằng cách gán nó cho biến `data`.\r\n\r\nNếu ta muốn truy cập giá trị đã hoàn thành của promise, trong trường hợp này là `\"I made it\"`, ta có thể sử dụng hàm `.then()` ngay sau `data` như sau:\r\n\r\n`data.then(res => console.log(res))`\r\n\r\nKhi này nó sẽ ghi ra `\"I made it!\"`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 74,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction addToList(item, list) {\r\n  return list.push(item);\r\n}\r\n\r\nconst result = addToList(\"apple\", [\"banana\"]);\r\nconsole.log(result);\r\n```\r\n\r\n- A: `['apple', 'banana']`\r\n- B: `2`\r\n- C: `true`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nHàm `.push()` trả về _độ dài_ của mảng mới! Trước đó, mảng chỉ hồm một phần tử là `\"banana\"` và có độ dài là `1`. Sau khi thêm chuỗi `\"apple\"` vào mảng, mảng lúc này có hai chuỗi và có độ dài là `2`. Do đó hàm `addToList` sẽ trả về 2.\r\n\r\nHàm `push` sẽ thay đổi chính bản thân mảng truyền vào. Do đó nếu chúng ta muốn trả về _mảng_ thay vì chỉ trả về _độ dài_, chúng ta nên trả về trực tiếp mảng `list` sau khi đã thêm `item` vào đó.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 75,
        "title": "Output là gì",
        "content": "```javascript\r\nconst box = { x: 10, y: 20 };\r\n\r\nObject.freeze(box);\r\n\r\nconst shape = box;\r\nshape.x = 100;\r\n\r\nconsole.log(shape);\r\n```\r\n\r\n- A: `{ x: 100, y: 20 }`\r\n- B: `{ x: 10, y: 20 }`\r\n- C: `{ x: 100 }`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\n`Object.freeze` khiến cho chúng ta không thể thêm vào, xóa đi hay thay đổi bất kì thuộc tính nào của object (trừ phi giá trị của thuộc tính lại chính là một object khác).\r\n\r\nKhi chúng ta tạo ra biến `shape` và set cho nó giá trị bằng với một object đã được đóng băng là `box`, thì `shape` cũng sẽ trỏ tới một object đã được đóng băng. Ta có thể check một object có đang bị đóng băng hay không bằng `Object.isFrozen`. Trong trường hợp này, `Object.isFrozen(shape)` trả về true, vì `shape` đang trỏ tới một object bị đóng băng.\r\n\r\nDo đó, cộng với việc `x` không phải là object, ta sẽ không thể thay đổi giá trị của `x`. `x` sẽ vẫn là `10`, và `{ x: 10, y: 20 }` được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 76,
        "title": "Output là gì",
        "content": "```javascript\r\nconst { name: myName } = { name: \"Lydia\" };\r\n\r\nconsole.log(name);\r\n```\r\n\r\n- A: `\"Lydia\"`\r\n- B: `\"myName\"`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nKhi ta tiến hành unpack giá trị `name` từ object ở phía bên phải, ta đã gán giá trị `\"Lydia\"` của nó cho biến có tên là `myName`.\r\n\r\nVới cú pháp `{ name: myName }`, chúng ta muốn khai báo một biến `myName` với giá trị là giá trị của thuộc tính `name` trong object phía bên phải.\r\n\r\nDo `name` chưa được định nghĩa, nên ghi log ra, nó sẽ throw ra một ReferenceError.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 77,
        "title": "Đây có phải là một pure function không",
        "content": "```javascript\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n- A: Yes\r\n- B: No\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nMột hàm được gọi là _pure function_ khi nó luôn luôn trả về một giá trị giống nhau, nếu đối số đưa vào là giống nhau.\r\n\r\nHàm `sum` luôn trả về giá trị giống nhau. Nếu ta đưa vào `1` và `2`, nó sẽ _luôn_ trả về `3`. Nếu ta đưa vào `5` và `10`, nó _luôn_ trả về `15`. Cứ như vậy, đây là một _pure function_.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 78,
        "title": "Output là gì",
        "content": "```javascript\r\nconst add = () => {\r\n  const cache = {};\r\n  return (num) => {\r\n    if (num in cache) {\r\n      return `From cache! ${cache[num]}`;\r\n    } else {\r\n      const result = num + 10;\r\n      cache[num] = result;\r\n      return `Calculated! ${result}`;\r\n    }\r\n  };\r\n};\r\n\r\nconst addFunction = add();\r\nconsole.log(addFunction(10));\r\nconsole.log(addFunction(10));\r\nconsole.log(addFunction(5 * 2));\r\n```\r\n\r\n- A: `Calculated! 20` `Calculated! 20` `Calculated! 20`\r\n- B: `Calculated! 20` `From cache! 20` `Calculated! 20`\r\n- C: `Calculated! 20` `From cache! 20` `From cache! 20`\r\n- D: `Calculated! 20` `From cache! 20` `Error`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nHàm `add` chính là một hàm _memoized_ (hàm có nhớ). Với việc có nhớ, chúng ta có thể cache lại kết quả của function để tăng tốc độ tính toán lên. Trong trường hợp này, chúng ta tạo ra một `cache` object để lưu trữ những kết quả tính toán trước đó.\r\n\r\nMỗi lần chúng ta gọi hàm `addFunction` với đối số giống nhau, đầu tiên nó sẽ check xem đối số đó có tồn tại trong cache hay không. Nếu có, giá trị trong cache sẽ được trả về luôn, tiết kiệm thời gian tính toán. Còn nếu không thì nó sẽ tiến hành tính toán kết quả và tiếp tục lưu vào cache.\r\n\r\nChúng ta gọi hàm `addFunction` ba lần với cùng một đối số: trong lần gọi đầu tiên, giá trị của `num` là `10` và chưa có mặt trong cache. Do đó `num in cache` trả về `false`, và sẽ chạy vào else block: `Calculated! 20` sẽ được ghi ra, và 10 sẽ được đưa vào cạche. `cache` khi này sẽ là `{ 10: 20 }`.\r\n\r\nTại lần gọi thứ hai, `cache` object đã có giá trị `10`. `num in cache` trả về `true`, và `'From cache! 20'` được ghi ra.\r\n\r\nTại lần gọi thứ ba, ta đưa vào `5 * 2`, tức `10` vào hàm. Tiếp tục giống như trên, `'From cache! 20'` sẽ được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 79,
        "title": "Output là gì",
        "content": "```javascript\r\nconst myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"];\r\n\r\nfor (let item in myLifeSummedUp) {\r\n  console.log(item);\r\n}\r\n\r\nfor (let item of myLifeSummedUp) {\r\n  console.log(item);\r\n}\r\n```\r\n\r\n- A: `0` `1` `2` `3` and `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`\r\n- B: `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` and `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`\r\n- C: `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` and `0` `1` `2` `3`\r\n- D: `0` `1` `2` `3` and `{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới vòng lặp _for-in_, chúng ta có thể duyệt qua các thuộc tính **enumerable** của object. Với mảng, thuộc tính enumerable chính là các \"key\" của mảng, hay chính là các index của mảng đó. Ta có thể coi mảng như là:\r\n\r\n`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`\r\n\r\nDo đó `0` `1` `2` `3` được ghi ra.\r\n\r\nVới vòng lặp _for-of_, chúng ta sẽ duyệt qua các phần tử của một **iterable**. Một mảng chính là một iterable. Khi chúng ta duyệt qua mảng, biến \"item\" chính là phần tử mà nó đang duyệt qua, do đó `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 80,
        "title": "Output là gì",
        "content": "```javascript\r\nconst list = [1 + 2, 1 * 2, 1 \/ 2];\r\nconsole.log(list);\r\n```\r\n\r\n- A: `[\"1 + 2\", \"1 * 2\", \"1 \/ 2\"]`\r\n- B: `[\"12\", 2, 0.5]`\r\n- C: `[3, 2, 0.5]`\r\n- D: `[1, 1, 1]`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMảng có thể nhận bất cứ giá trị nào. Số, chuỗi, objects, mảng khác, null, boolean, undefined, và nhiều dạng biểu thức nữa như ngày tháng, hàm, và các tính toán.\r\n\r\nGiá trị của phần tử chính là giá trị trả về. `1 + 2` trả về `3`, `1 * 2` trả về `2`, và `1 \/ 2` trả về `0.5`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 81,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction sayHi(name) {\r\n  return `Hi there, ${name}`;\r\n}\r\n\r\nconsole.log(sayHi());\r\n```\r\n\r\n- A: `Hi there, `\r\n- B: `Hi there, undefined`\r\n- C: `Hi there, null`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nMặc định, đối số sẽ có giá trị là `undefined`, trừ phi ta gán giá trị cho nó khi đưa vào hàm. Trong trường hợp này, ta không đưa vào giá trị nào cho đối số `name` cả. Do đó `name` sẽ là `undefined` và được ghi ra.\r\n\r\nVới cú pháp ES6, ta có thể thay đổi giá trị mặc định `undefined` bằng một giá trị mặc định khác. Ví dụ:\r\n\r\n`function sayHi(name = \"Lydia\") { ... }`\r\n\r\nTrong trường hợp này, nếu ta không đưa giá trị nào vào hoặc đưa vào `undefined`, `name` cũng sẽ nhận giá trị mặc định là `Lydia`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 82,
        "title": "Output là gì",
        "content": "```javascript\r\nvar status = \"😎\";\r\n\r\nsetTimeout(() => {\r\n  const status = \"😍\";\r\n\r\n  const data = {\r\n    status: \"🥑\",\r\n    getStatus() {\r\n      return this.status;\r\n    },\r\n  };\r\n\r\n  console.log(data.getStatus());\r\n  console.log(data.getStatus.call(this));\r\n}, 0);\r\n```\r\n\r\n- A: `\"🥑\"` and `\"😍\"`\r\n- B: `\"🥑\"` and `\"😎\"`\r\n- C: `\"😍\"` and `\"😎\"`\r\n- D: `\"😎\"` and `\"😎\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nGiá trị của `this` phụ thuộc vào vị trí mà nó được gọi. Trong một **phương thức**, ví dụ `getStatus`, `this` trỏ tới _object chứa phương thức đó_. Phương thức này thuộc `data` object, do đó `this` trỏ tới `data` object. Khi chúng ta gọi `this.status` thì thuộc tính `status` của `data` sẽ được ghi ra, chính là `\"🥑\"`.\r\n\r\nVới phương thức `call`, chúng ta thay đổi tham chiếu mà `this` trỏ tới. Trong **hàm**, từ khóa `this` trỏ tới _object chứa hàm đó_. Chúng ta khai báo hàm `setTimeout` trong _global object_, do đó bên trong hàm `setTimeout` thì `this` sẽ trỏ tới _global object_. Tại biến global object, có một biến _status_ với giá trị `\"😎\"`. Do đó khi gọi `this.status`, `\"😎\"` sẽ được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 83,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21,\r\n};\r\n\r\nlet city = person.city;\r\ncity = \"Amsterdam\";\r\n\r\nconsole.log(person);\r\n```\r\n\r\n- A: `{ name: \"Lydia\", age: 21 }`\r\n- B: `{ name: \"Lydia\", age: 21, city: \"Amsterdam\" }`\r\n- C: `{ name: \"Lydia\", age: 21, city: undefined }`\r\n- D: `\"Amsterdam\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nChúng ta set biến `city` bằng với giá trị của thuộc tính `city` của object `person`. Nhưng object này không có thuộc tính nào là `city` cả, nên giá trị của biến `city` sẽ là `undefined`.\r\n\r\nChú ý là chúng ta _không tham chiếu_ tới bản thân object `person`! Chúng ta chỉ đơn giản là set giá trị của biến `city` bằng với giá trị của thuộc tính `city` trong object `person` mà thôi.\r\n\r\nSau đó chúng ta set biến `city` bằng với chuỗi `\"Amsterdam\"`. Điều này không hề ảnh hưởng gì tới object person vì không có tham chiếu nào ở đây cả.\r\n\r\nDo đó khi ghi object `person` ra, Tất cả các thuộc tính vẫn như cũ không hề thay đổi gì cả.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 84,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction checkAge(age) {\r\n  if (age < 18) {\r\n    const message = \"Sorry, you're too young.\";\r\n  } else {\r\n    const message = \"Yay! You're old enough!\";\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\nconsole.log(checkAge(21));\r\n```\r\n\r\n- A: `\"Sorry, you're too young.\"`\r\n- B: `\"Yay! You're old enough!\"`\r\n- C: `ReferenceError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nBiến số được khai báo với các từ khóa như `const` hay `let` đều là _block-scoped_. Block chính là những khối được bao bọc bởi cặp ngoặc nhọn (`{ }`). Trong trường hợp này nó chính là cặp ngoặc bao quanh những câu lệnh `if\/else`. Chúng ta không thể truy cập đến biến đó bên ngoài block, và kết quả là throw một ReferenceError.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 85,
        "title": "Những thông tin nào sẽ được ghi ra",
        "content": "```javascript\r\nfetch(\"https:\/\/www.website.com\/api\/user\/1\")\r\n  .then((res) => res.json())\r\n  .then((res) => console.log(res));\r\n```\r\n\r\n- A: The result of the `fetch` method.\r\n- B: The result of the second invocation of the `fetch` method.\r\n- C: The result of the callback in the previous `.then()`.\r\n- D: It would always be undefined.\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nGiá trị của `res` trong `.then` thứ hai chính là giá trị trả về từ `.then` trước đó. Chúng ta có thể thực hiện `.then` liên tiếp như vậy, các giá trị sẽ liên tiếp được truyền tới hàm xử lý tiếp theo.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 86,
        "title": "Bằng cách nào chúng ta có thể set `hasName` bằng `true`, nếu chúng ta không đưa `true` vào đối số",
        "content": "```javascript\r\nfunction getName(name) {\r\n  const hasName = \/\/\r\n}\r\n```\r\n\r\n- A: `!!name`\r\n- B: `name`\r\n- C: `new Boolean(name)`\r\n- D: `name.length`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới `!!name`, chúng ta sẽ đánh giá giá trị của `name` là _truthy_ hay _falsy_. Nếu name là truthy, thì `!name` sẽ trả về `false`. `!false` (hay chính là `!!name` khi này) sẽ trả về `true`.\r\n\r\nBằng cách set `hasName` bằng với `name`, chúng ta set `hasName` bằng với giá trị đối số đưa vào trong hàm `getName`, không thỏa mãn vì ta đã giới hạn là không đưa `true` vào.\r\n\r\n`new Boolean(true)` trả về một object wrapper, chứ không phải là một giá trị boolean.\r\n\r\n`name.length` trả về độ dài của đối số, chứ không phải `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 87,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(\"I want pizza\"[0]);\r\n```\r\n\r\n- A: `\"\"\"`\r\n- B: `\"I\"`\r\n- C: `SyntaxError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTrong trường hợp ta muốn lấy ra một ký tự trong một chuỗi, ta có thể sử dụng toán tử ngoặc vuông. Ký tự đầu tiên sẽ có thứ tự là 0, và cứ tiếp tục như vậy. Trong trường hợp này chúng ta lấy ra ký tự có thứ tự là 0, đó chính là ký tự `\"I'`.\r\n\r\nChú ý là phương thức này không hoạt động với IE7 trở xuống. Thay vì thế ta sử dụng `.charAt()`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 88,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction sum(num1, num2 = num1) {\r\n  console.log(num1 + num2);\r\n}\r\n\r\nsum(10);\r\n```\r\n\r\n- A: `NaN`\r\n- B: `20`\r\n- C: `ReferenceError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTa có thể set giá trị mặc định của một tham số là tham số khác trong hàm, miễn là tham số đó được khai báo _trước_ tham số mặc định. Chúng ta đưa `10` vào hàm `sum`. Nếu hàm `sum` chỉ nhận 1 đối số, nó có nghĩa là giá trị của `num2` không được đưa vào, nên nó sẽ lấy giá trị mặc định là giá trị của `num1` đã được đưa vào, hay chính là `10` trong trường hợp này. Khi này `num1 + num2` trả về `20`.\r\n\r\nNếu chúng ta thử set một giá trị mặc định của tham số bằng với giá trị của tham số khai báo _sau_ (về bên phải), giá trị của tham số đó sẽ không được khởi tạo và dẫn đến throw ra lỗi.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 89,
        "title": "Output là gì",
        "content": "```javascript\r\n\/\/ module.js\r\nexport default () => \"Hello world\";\r\nexport const name = \"Lydia\";\r\n\r\n\/\/ index.js\r\nimport * as data from \".\/module\";\r\n\r\nconsole.log(data);\r\n```\r\n\r\n- A: `{ default: function default(), name: \"Lydia\" }`\r\n- B: `{ default: function default() }`\r\n- C: `{ default: \"Hello world\", name: \"Lydia\" }`\r\n- D: Global object of `module.js`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nCú pháp `import * as data` sẽ import _tất cả những gì được export_ từ `module.js` vào trong `index.js` và lưu trữ dưới một object có tên là `data`. Trong file `module.js`, có hai thứ được export ra: default export và một named export. Default export là một hàm trả về chuỗi `\"Hello World\"`, và named export là một biến `name` nhận giá trị là chuỗi `\"Lydia\"`.\r\n\r\nDo đó `data` object có thuộc tính `default` cho default export, các thuộc tính khác sẽ có tên chính là tên của named exports và giá trị đi kèm.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 90,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Person {\r\n  constructor(name) {\r\n    this.name = name;\r\n  }\r\n}\r\n\r\nconst member = new Person(\"John\");\r\nconsole.log(typeof member);\r\n```\r\n\r\n- A: `\"class\"`\r\n- B: `\"function\"`\r\n- C: `\"object\"`\r\n- D: `\"string\"`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nClasses chỉ đơn thuần là `syntactical sugar` (cú pháp đặc biệt) của function constructors mà thôi. Nó tương đương với việc ta viết một function thế này:\r\n\r\n```javascript\r\nfunction Person() {\r\n  this.name = name;\r\n}\r\n```\r\n\r\nGọi một constructor với từ khóa `new` sẽ tạo ra một instance của class `Person`, `typeof` sẽ trả về là `\"object\"` cho các instance. Do đó `typeof member` trả về `\"object\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 91,
        "title": "Output là gì",
        "content": "```javascript\r\nlet newList = [1, 2, 3].push(4);\r\n\r\nconsole.log(newList.push(5));\r\n```\r\n\r\n- A: `[1, 2, 3, 4, 5]`\r\n- B: `[1, 2, 3, 5]`\r\n- C: `[1, 2, 3, 4]`\r\n- D: `Error`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nHàm `.push` trả về _độ dài mới_ của mảng, chứ không phải bản thân mảng đó! Bằng cách set `newList` bằng với `[1, 2, 3].push(4)`, ta đã set cho `newList` giá trị là `4` - tức độ dài của mảng lúc này.\r\n\r\nSau đó chúng ta tiến hành `.push` trên `newList`. Vì `newList` là một số thông thường, ta không thể dùng `.push` được, nên sẽ throw ra một TypeError.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 92,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction giveLydiaPizza() {\r\n  return \"Here is pizza!\";\r\n}\r\n\r\nconst giveLydiaChocolate = () =>\r\n  \"Here's chocolate... now go hit the gym already.\";\r\n\r\nconsole.log(giveLydiaPizza.prototype);\r\nconsole.log(giveLydiaChocolate.prototype);\r\n```\r\n\r\n- A: `{ constructor: ...}` `{ constructor: ...}`\r\n- B: `{}` `{ constructor: ...}`\r\n- C: `{ constructor: ...}` `{}`\r\n- D: `{ constructor: ...}` `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nHàm thông thường giống như `giveLydiaPizza`, sẽ có thuộc tính `prototype` là một object (prototype object) với một thuộc tính là `constructor`. Còn `arrow functions` giống như `giveLydiaChocolate`thì không có thuộc tính `prototype` này. `undefined` trả về khi ta truy cập thuộc tính `prototype` bằng cách gọi `giveLydiaChocolate.prototype`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 93,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21,\r\n};\r\n\r\nfor (const [x, y] of Object.entries(person)) {\r\n  console.log(x, y);\r\n}\r\n```\r\n\r\n- A: `name` `Lydia` và `age` `21`\r\n- B: `[\"name\", \"Lydia\"]` và `[\"age\", 21]`\r\n- C: `[\"name\", \"age\"]` và `undefined`\r\n- D: `Error`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\n`Object.entries(person)` sẽ trả về một mảng của mảng, bao gồm các key và các object:\r\n\r\n`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`\r\n\r\nKhí sử dụng `for-of`, chúng ta sẽ duyệt qua từng thành phần của mảng, trong trường hợp này chính là những mảng con. Đồng thời tiến hành gán giá trị luôn trong vongf lặp for-of, bằng cách sử dụng `const [x, y]`. Khi này `x` sẽ là phần tử đầu tiên trong mảng con, `y` chính là phần tử thứ hai trong mảng con.\r\n\r\nMảng con đầu tiên là `[ \"name\", \"Lydia\" ]`, nên `x` sẽ là `\"name\"`, và `y` sẽ là `\"Lydia\"`, và được ghi ra.\r\nMảng con thứ hai là `[ \"age\", 21 ]`, nên `x` sẽ là `\"age\"`, và `y` sẽ là `21`, và được ghi ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 94,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getItems(fruitList, ...args, favoriteFruit) {\r\n  return [...fruitList, ...args, favoriteFruit]\r\n}\r\n\r\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\r\n```\r\n\r\n- A: `[\"banana\", \"apple\", \"pear\", \"orange\"]`\r\n- B: `[[\"banana\", \"apple\"], \"pear\", \"orange\"]`\r\n- C: `[\"banana\", \"apple\", [\"pear\"], \"orange\"]`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\n`...args` là cú pháp tham số cuối cùng. Giá trị của tham số cuối cùng chính là toàn bộ các đối số còn lại, **và nó là tham số cuối cùng duy nhất**! Trong trường hợp này, tham số cuối cùng lại là tham số thứ hai. Điều đó là không thể được, và sẽ throw ra một lỗi cú pháp.\r\n\r\n```javascript\r\nfunction getItems(fruitList, favoriteFruit, ...args) {\r\n  return [...fruitList, ...args, favoriteFruit];\r\n}\r\n\r\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\");\r\n```\r\n\r\nNếu ta code như thế này thì lại đúng. Giá trị trả về sẽ là `[ 'banana', 'apple', 'orange', 'pear' ]`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 95,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction nums(a, b) {\r\n  if (a > b) console.log(\"a is bigger\");\r\n  else console.log(\"b is bigger\");\r\n  return;\r\n  a + b;\r\n}\r\n\r\nconsole.log(nums(4, 2));\r\nconsole.log(nums(1, 2));\r\n```\r\n\r\n- A: `a is bigger`, `6` và `b is bigger`, `3`\r\n- B: `a is bigger`, `undefined` và `b is bigger`, `undefined`\r\n- C: `undefined` và `undefined`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới JavaScript, ta _không bắt buộc_ phải viết dấu chấm phẩy (`;`), JavaScript engine sẽ tự động thêm vào sau mỗi câu lệnh. Nó gọi là **Automatic Semicolon Insertion**. Một câu lệnh có thể là khai báo biến, hoặc từ khóa như `throw`, `return`, `break`, vv.\r\n\r\nỞ đây ta sử dụng câu lệnh `return` ở một dòng và giá trị `a + b` ở một _dòng khác_. Tuy nhiên do khác dòng nên JS engine không thể biết đâu là giá trị ta thực sự muốn trả về. Thay vì thế, nó sẽ tự động thêm vào dấu chấm phẩy ngay sau `return` giống như này:\r\n\r\n```javascript\r\nreturn;\r\na + b;\r\n```\r\n\r\nCó nghĩa là `a + b` sẽ không bao giờ được thực hiện, vì hàm đã được `return` rồi. Do không giá trị nào được trả về, nên giá trị trả về của hàm sẽ là `undefined`. Lưu ý là sẽ không tự động thêm dấu chấm phẩy ngay sau `if\/else` đâu nhé!\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 96,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Person {\r\n  constructor() {\r\n    this.name = \"Lydia\";\r\n  }\r\n}\r\n\r\nPerson = class AnotherPerson {\r\n  constructor() {\r\n    this.name = \"Sarah\";\r\n  }\r\n};\r\n\r\nconst member = new Person();\r\nconsole.log(member.name);\r\n```\r\n\r\n- A: `\"Lydia\"`\r\n- B: `\"Sarah\"`\r\n- C: `Error: cannot redeclare Person`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nChúng ta có thể set một class với giá trị là một classes\/function constructor khác. Trong trường hợp này, ta set `Person` bằng với `AnotherPerson`. Trong constructor, `this.name` là `Sarah`, do đó giá trị của thuộc tính này trong instance `member` chính là `\"Sarah\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 97,
        "title": "Output là gì",
        "content": "```javascript\r\nconst info = {\r\n  [Symbol(\"a\")]: \"b\",\r\n};\r\n\r\nconsole.log(info);\r\nconsole.log(Object.keys(info));\r\n```\r\n\r\n- A: `{Symbol('a'): 'b'}` và `[\"{Symbol('a')\"]`\r\n- B: `{}` và `[]`\r\n- C: `{ a: \"b\" }` và `[\"a\"]`\r\n- D: `{Symbol('a'): 'b'}` và `[]`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nPhương thức `Object.keys` sẽ trả về toàn bộ những key của các thuộc tính _enumerable_ trên một object. Nhưng Symbol không phải dạng _enumerable_. do đó nó sẽ trả về một mảng rỗng. Tuy nhiên khi ta log ra toàn bộ object, thì ta sẽ ghi ra toàn bộ các thuộc tính, cho dù đó có là thuộc tính _enumerable_ hay không.\r\n\r\nĐó chính là một đặc trưng của Symbol: Bên cạnh việc nó biểu diễn một giá trị duy nhất (tránh việc xảy ra xung đột tên gọi, ví dụ khi ta sử dụng 2 thư viện mà muốn thêm thuộc tính vào cho cùng một object chẳng hạn), nó còn giúp \"ẩn\" thuộc tính đó đi (dù không hoàn toàn, ta vẫn có thể truy cập được bằng cách sử dụng phương thức `Object.getOwnPropertySymbols()`).\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 98,
        "title": "Output là gì",
        "content": "```javascript\r\nconst getList = ([x, ...y]) => [x, y]\r\nconst getUser = user => { name: user.name, age: user.age }\r\n\r\nconst list = [1, 2, 3, 4]\r\nconst user = { name: \"Lydia\", age: 21 }\r\n\r\nconsole.log(getList(list))\r\nconsole.log(getUser(user))\r\n```\r\n\r\n- A: `[1, [2, 3, 4]]` và `undefined`\r\n- B: `[1, [2, 3, 4]]` và `{ name: \"Lydia\", age: 21 }`\r\n- C: `[1, 2, 3, 4]` và `{ name: \"Lydia\", age: 21 }`\r\n- D: `Error` và `{ name: \"Lydia\", age: 21 }`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nHàm `getList` nhận vào một mảng các đối số, và tiến hành xử lý mảng đó luôn khi đưa vào hàm:\r\n\r\n`[x, ...y] = [1, 2, 3, 4]`\r\n\r\nVới việc sử dụng cú pháp tham số cuối cùng `...y`, chúng ta đưa toàn bộ \"những đối số còn lại\" vào một mảng y. Trong trường hợp này đó là mảng gồm các phần tử `2`, `3` và `4`. Do đó giá trị của `y` lúc này chính là mảng `[2, 3, 4]`. Giá trị của `x` là `1`, nên khi ghi `[x, y]` ra, kết quả sẽ là `[1, [2, 3, 4]]`.\r\n\r\nHàm `getUser` nhận vào một object. Với cú pháp arrow function, chúng ta sẽ không phải viết trong ngoặc nhọn `{}` nữa nếu ta chỉ muốn đơn thuần trả về giá trị. Tuy nhiên, nếu ta muốn trả về một _object_ t arrow function, ta sẽ phải viết chúng trong dấu ngoặc tròn `()`, nếu không thì sẽ không có giá trị nào được trả về! Ví dụ như sau:\r\n\r\n`const getUser = user => ({ name: user.name, age: user.age })`\r\n\r\nDo không giá trị nào được trả về, kết quả sẽ là `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 99,
        "title": "Output là gì",
        "content": "```javascript\r\nconst name = \"Lydia\";\r\n\r\nconsole.log(name());\r\n```\r\n\r\n- A: `SyntaxError`\r\n- B: `ReferenceError`\r\n- C: `TypeError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nBiến `name` có giá trị là một chuỗi, không phải hàm, vì thế không thể gọi được.\r\n\r\nTypeErrors sẽ được throw ra nếu một giá trị không được sử dụng đúng kiểu. JavaScript muốn `name` là một hàm khi ta tiến hành gọi nó. Nhưng nó là chuỗi, nên sẽ throw ra một TypeError.\r\n\r\nSyntaxErrors sẽ được throw khi ta viết code không đúng cú pháp của JavaScript, ví dụ thay vì `return` ta viết `retrun`.\r\n\r\nReferenceErrors sẽ được throw ra khi Javascript không thể tìm được tham chiếu nào đến giá trị mà ta đang cố truy cập.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 100,
        "title": "Output là gì",
        "content": "```javascript\r\n\/\/ 🎉✨ Đây là câu hỏi thứ 100 của tôi! ✨🎉\r\n\r\nconst output = `${[] && \"Im\"}possible!\r\nYou should${\"\" && `n't`} see a therapist after so much JavaScript lol`;\r\n```\r\n\r\n- A: `possible! You should see a therapist after so much JavaScript lol`\r\n- B: `Impossible! You should see a therapist after so much JavaScript lol`\r\n- C: `possible! You shouldn't see a therapist after so much JavaScript lol`\r\n- D: `Impossible! You shouldn't see a therapist after so much JavaScript lol`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\n`[]` là một giá trị truthy. Với phép toán `&&` , giá trị bên phải sẽ được trả về nếu giá trị bên trái là truthy. Trong trường hợp này giá trị bên trái `[]` là truthy, nên `\"Im'` sẽ được trả về.\r\n\r\n`\"\"` là một giá trị falsy. Nếu giá trị bên trái là falsy, không có gì được trả về cả. Do đó `n't` sẽ không được trả về.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 101,
        "title": "Output là gì",
        "content": "```javascript\r\nconst one = false || {} || null;\r\nconst two = null || false || \"\";\r\nconst three = [] || 0 || true;\r\n\r\nconsole.log(one, two, three);\r\n```\r\n\r\n- A: `false` `null` `[]`\r\n- B: `null` `\"\"` `true`\r\n- C: `{}` `\"\"` `[]`\r\n- D: `null` `null` `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới phép toán `||`, ta sẽ trả về giá trị truethy đầu tiên. Nếu tất cả đều là falsy, giá trị cuối cùng sẽ được trả về.\r\n\r\n`(false || {} || null)`: object rỗng `{}` là một giá trị truthy. Nó là giá trị truethy đầu tiên và duy nhất nên sẽ được trả về. Do đó `one` sẽ là `{}`.\r\n\r\n`(null || false || \"\")`: Tất cả toán hạng đều là falsy. Có nghĩa là toán hạng cuối cùng `\"\"` sẽ được trả về. Do đó `two` sẽ là `\"\"`.\r\n\r\n`([] || 0 || \"\")`: mảng rỗng `[]` là một giá trị truthy. Nó là giá trị truthy đầu tiên nên sẽ được trả về. Do đó `three` sẽ là `[]`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 102,
        "title": "Output là gì",
        "content": "```javascript\r\nconst myPromise = () => Promise.resolve(\"I have resolved!\");\r\n\r\nfunction firstFunction() {\r\n  myPromise().then((res) => console.log(res));\r\n  console.log(\"second\");\r\n}\r\n\r\nasync function secondFunction() {\r\n  console.log(await myPromise());\r\n  console.log(\"second\");\r\n}\r\n\r\nfirstFunction();\r\nsecondFunction();\r\n```\r\n\r\n- A: `I have resolved!`, `second` và `I have resolved!`, `second`\r\n- B: `second`, `I have resolved!` và `second`, `I have resolved!`\r\n- C: `I have resolved!`, `second` và `second`, `I have resolved!`\r\n- D: `second`, `I have resolved!` và `I have resolved!`, `second`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nCó thể tưởng tượng đơn giản cách promise thực thi như sau: _bây giờ tôi sẽ để tạm nó sang một bên vì nó tính toán mất thời gian. Chỉ khi nào nó được hoàn thành (resolved) hay bị hủy bỏ (rejected) hay khi call stack trở nên rỗng thì tôi sẽ lấy giá trị trả về ra._\r\n\r\nDù chúng ta có thể sử dụng giá trị thu được bằng cú pháp `.then`, hoặc sử dụng cặp cú pháp `await\/async`, nhưng, cách chúng hoạt động là khác nhau.\r\n\r\nTrong `firstFunction`, chúng ta đưa promise qua một bên chờ cho nó tính toán xong, và vẫn tiếp tục chạy những code tiếp sau đó, theo đó `console.log('second')` sẽ được chạy. Sau đó promise được hoàn thành trả về giá trị `I have resolved`, giá trị này sẽ được log ra khi call stack trở nên rỗng.\r\n\r\nVới từ khóa `await` trong `secondFunction`, ta đã tạm dừng một hàm bất đồng bộ cho tới khi chúng trả về giá trị, sau đó ta mới đi tiếp đến các câu lệnh tiếp theo.\r\n\r\nDo đó nó sẽ chờ cho tới khi `myPromise` được hoàn thành và trả về giá trị `I have resolved`, sau đó chúng ta sẽ chạy tiếp câu lệnh tiếp theo in ra `second`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 103,
        "title": "Output là gì",
        "content": "```javascript\r\nconst set = new Set();\r\n\r\nset.add(1);\r\nset.add(\"Lydia\");\r\nset.add({ name: \"Lydia\" });\r\n\r\nfor (let item of set) {\r\n  console.log(item + 2);\r\n}\r\n```\r\n\r\n- A: `3`, `NaN`, `NaN`\r\n- B: `3`, `7`, `NaN`\r\n- C: `3`, `Lydia2`, `[object Object]2`\r\n- D: `\"12\"`, `Lydia2`, `[object Object]2`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nPhép toán `+` không chỉ dùng để cộng các số, mà nó còn dùng để nối chuỗi nữa. Mỗi khi Javascript engine gặp một giá trị trong phép toán không phải dạng số, nó sẽ chuyển các số trong phép toán đó sang dạng chuỗi.\r\n\r\nPhép toán đầu tiên item là một số `1`, nên `1 + 2` trả về 3.\r\n\r\nỞ phép toán thứ hai, item là một chuỗi `\"Lydia\"`. trong khi đó `2` là một số, nên `2` sẽ bị chuyển sang dạng chuỗi, sau khi nối vào ta có chuỗi `\"Lydia2\"`.\r\n\r\nỞ phép toán thứ ba, `{ name: \"Lydia\" }` là một object. Tuy nhiên dù có là object hay gì đi nữa thì nó cũng sẽ bị chuyển sang dạng chuỗi. Đối với object thì khi chuyển sang dạng chuỗi nó sẽ trở thành `\"[object Object]\"`. `\"[object Object]\"` nối với `\"2\"` trở thành `\"[object Object]2\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 104,
        "title": "Output là gì",
        "content": "```javascript\r\nPromise.resolve(5);\r\n```\r\n\r\n- A: `5`\r\n- B: `Promise {: 5}`\r\n- C: `Promise {: 5}`\r\n- D: `Error`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nTa có thể truyền vào giá trị bất kì cho `Promise.resolve`, dù có là promise hay không promise. Bản thân nó sẽ là một hàm trả về một promise với giá trị đã được resolved.\r\n\r\nTrong trường hợp này ta đưa vào giá trị `5`. Nó sẽ trả về một resolved promise với giá trị `5`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 105,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction compareMembers(person1, person2 = person) {\r\n  if (person1 !== person2) {\r\n    console.log(\"Not the same!\");\r\n  } else {\r\n    console.log(\"They are the same!\");\r\n  }\r\n}\r\n\r\nconst person = { name: \"Lydia\" };\r\n\r\ncompareMembers(person);\r\n```\r\n\r\n- A: `Not the same!`\r\n- B: `They are the same!`\r\n- C: `ReferenceError`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nObject sẽ được truyền vào hàm theo reference. Khi chúng ta nói so sánh strict equal (`===`), nghĩa là ta đang so sánh các reference của chúng.\r\n\r\nTa set giá trị mặc định của `person2` là object `person`, và đưa object `person` vào làm giá trị cho đối số `person1`.\r\n\r\nĐiều đó có nghĩa là chúng cùng trỏ đến một object trong bộ nhớ, do đó chúng bằng nhau, và `They are the same!` được in ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 106,
        "title": "Output là gì",
        "content": "```javascript\r\nconst colorConfig = {\r\n  red: true,\r\n  blue: false,\r\n  green: true,\r\n  black: true,\r\n  yellow: false,\r\n};\r\n\r\nconst colors = [\"pink\", \"red\", \"blue\"];\r\n\r\nconsole.log(colorConfig.colors[1]);\r\n```\r\n\r\n- A: `true`\r\n- B: `false`\r\n- C: `undefined`\r\n- D: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nTrong Javascript ta có hai cách để truy cập thuộc tính của một object: sử dụng ngoặc vuông `[]`, hoặc sử dụng chấm `.`. Trong trương hợp này chúng ta sử dụng chấm (`colorConfig.colors`) thay cho ngoặc vuông (`colorConfig[\"colors\"]`).\r\n\r\nVới cách sử dụng chấm, Javascript sẽ tìm kiếm một thuộc tính có tên chính xác như tên ta đưa vào. Trong trường hợp này nó là thuộc tính `colors` trong object `colorConfig` Tuy nhiên trong object này không có thuộc tính nào tên là `colors`, nên nó sẽ trả về `undefined`. Sau đó chúng ta cố truy cậ vào thuộc tính 1 của nó bằng cách gọi `[1]`. Chúng ta không thể làm như vậy trên giá trị `undefined`, nên nó sẽ trả về `TypeError`: `Cannot read property '1' of undefined`.\r\n\r\nJavascript thông dịch theo câu lệnh. Khi ta sử dụng ngoặc vuông, Nnó sẽ tìm mở ngoặc đầu tiên `[` và tiếp tục cho tới khi gặp đóng ngoặc tương ứng `]`. Chỉ khi đó nó mới đánh giá câu lệnh. Nếu chúng ta sử dụng cú pháp `colorConfig[colors[1]]`, nó sẽ trả về giá trị của thuộc tính `red` trong object `colorConfig`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 107,
        "title": "Ouput là gì",
        "content": "```javascript\r\nconsole.log(\"❤️\" === \"❤️\");\r\n```\r\n\r\n- A: `true`\r\n- B: `false`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVề cơ bản, emoji vẫn là các ký tự unicode mà thôi. Mã unicode cho hình trái tim là `\"U+2764 U+FE0F\"`. Chúng luôn luôn là một, nên phép toán đơn giản trả về `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 108,
        "title": "Phép toán nào sau đây làm thay đổi mảng gốc",
        "content": "```javascript\r\nconst emojis = [\"✨\", \"🥑\", \"😍\"];\r\n\r\nemojis.map((x) => x + \"✨\");\r\nemojis.filter((x) => x !== \"🥑\");\r\nemojis.find((x) => x !== \"🥑\");\r\nemojis.reduce((acc, cur) => acc + \"✨\");\r\nemojis.slice(1, 2, \"✨\");\r\nemojis.splice(1, 2, \"✨\");\r\n```\r\n\r\n- A: `All of them`\r\n- B: `map` `reduce` `slice` `splice`\r\n- C: `map` `slice` `splice`\r\n- D: `splice`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nVới `splice`, ta thay đổi mảng gốc bằng cách thêm sửa xóa các phần tử. Trong trường hợp này ta xóa 2 phần tử kể từ index 1 (ta xóa `'🥑'` và `'😍'`) và thêm vào ✨ emoji.\r\n\r\n`map`, `filter` và `slice` trả về một mảng mới, `find` trả về một phần tử, và `reduce` trả về giá trị tích lũy.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 109,
        "title": "Output là gì",
        "content": "```javascript\r\nconst food = [\"🍕\", \"🍫\", \"🥑\", \"🍔\"];\r\nconst info = { favoriteFood: food[0] };\r\n\r\ninfo.favoriteFood = \"🍝\";\r\n\r\nconsole.log(food);\r\n```\r\n\r\n- A: `['🍕', '🍫', '🥑', '🍔']`\r\n- B: `['🍝', '🍫', '🥑', '🍔']`\r\n- C: `['🍝', '🍕', '🍫', '🥑', '🍔']`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nTrong Javascript tất cả các kiểu cơ bản (mọi thứ không phải object) đều tương tác bằng _giá trị_. Chúng ta set giá trị của thuộc tính `favoriteFood` trong object `info` bằng ký tự bánh pizza, `'🍕'`. Chuỗi trong javascript là một kiểu cơ bản, nên nó cũng sẽ tương tác bằng giá trị.\r\n\r\nBản thân mảng `food` không hề thay đổi, do giá trị của `favoriteFood` chỉ là một bản _copy_ của giá trị đầu tiên trong mảng mà thôi, và không hề trỏ tới reference của `food[0]`. Do đó khi ghi ra, giá trị của mảng vẫn là giá trị ban đầu, `['🍕', '🍫', '🥑', '🍔']`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 110,
        "title": "Phép toán này dùng để làm gì",
        "content": "```javascript\r\nJSON.parse();\r\n```\r\n\r\n- A: Parse JSON thành một giá trị JavaScript\r\n- B: Parse một JavaScript object thành JSON\r\n- C: Parse giá trị JavaScript bất kì thành JSON\r\n- D: Parse JSON thành một JavaScript object\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới phương thức `JSON.parse()`, ta sẽ parse một chuỗi JSON thành một giá trị JavaScript.\r\n\r\nVí dụ:\r\n\r\n```javascript\r\n\/\/ Chuyển một số thành một chuỗi JSON, sau đó parse chuỗi JSON đó để trả về một giá trị JavaScript:\r\nconst jsonNumber = JSON.stringify(4); \/\/ '4'\r\nJSON.parse(jsonNumber); \/\/ 4\r\n\r\n\/\/ Chuyển một mảng thành một chuỗi JSON, sau đó parse chuỗi JSON để trả về một giá trị JavaScript:\r\nconst jsonArray = JSON.stringify([1, 2, 3]); \/\/ '[1, 2, 3]'\r\nJSON.parse(jsonArray); \/\/ [1, 2, 3]\r\n\r\n\/\/ Chuyển một object thành một chuỗi JSON, sau đó parse chuỗi JSON để trả về một giá trị JavaScript:\r\nconst jsonArray = JSON.stringify({ name: \"Lydia\" }); \/\/ '{\"name\":\"Lydia\"}'\r\nJSON.parse(jsonArray); \/\/ { name: 'Lydia' }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 111,
        "title": "Ouput là gì",
        "content": "```javascript\r\nlet name = \"Lydia\";\r\n\r\nfunction getName() {\r\n  console.log(name);\r\n  let name = \"Sarah\";\r\n}\r\n\r\ngetName();\r\n```\r\n\r\n- A: Lydia\r\n- B: Sarah\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nMỗi hàm sẽ có một _context thực thi_ (hay _scope_) của riêng nó. Hàm `getName` đầu tiên sẽ tìm trong context của nó (scope) để tìm xem có biến nào tên là `name` hay không. Trong trường hợp này, hàm `getName` có biến `name` được khai báo với từ khóa `let`, giá trị là `'Sarah'`.\r\n\r\nMột biến được khai báo với từ khóa `let` (hoặc `const`) sẽ được `hoisted`, nhưng không giống như `var`, nó sẽ không được _khởi tạo_. Nó sẽ không thể truy cập được trước dòng ta khai báo (initialize). Nó được gọi là \"temporal dead zone\". Khi ta cố truy cập một biến trước khi nó được khai báo, JavaScript sẽ throw ra `ReferenceError`.\r\n\r\nNếu ta không khai báo biến `name` bên trong hàm `getName`, thì Javascript engine sẽ tiếp tục tìm kiếm trong _scope chain_. Nó sẽ tìm thấy ở scope phía ngoài một biến `name` với giá trị là `Lydia`. Trong trường hợp này nó sẽ log ra `Lydia`.\r\n\r\n```javascript\r\nlet name = \"Lydia\";\r\n\r\nfunction getName() {\r\n  console.log(name);\r\n}\r\n\r\ngetName(); \/\/ Lydia\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 112,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction* generatorOne() {\r\n  yield [\"a\", \"b\", \"c\"];\r\n}\r\n\r\nfunction* generatorTwo() {\r\n  yield* [\"a\", \"b\", \"c\"];\r\n}\r\n\r\nconst one = generatorOne();\r\nconst two = generatorTwo();\r\n\r\nconsole.log(one.next().value);\r\nconsole.log(two.next().value);\r\n```\r\n\r\n- A: `a` and `a`\r\n- B: `a` and `undefined`\r\n- C: `['a', 'b', 'c']` and `a`\r\n- D: `a` and `['a', 'b', 'c']`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới từ khóa `yield`, ta sẽ trả về các giá trị trong một `generator`. Với từ khóa `yield*`, ta có thể trả về giá trị từ một `engerator` khác, hoặc một `iterable object` (ví dụ mảng).\r\n\r\nTrong `generatorOne`, ta trả về toàn bộ mảng `['a', 'b', 'c']` sử dụng từ khóa `yield`. Giá trị của thuộc tính `value` trong object thu được bởi phương thức `next` trong `one` (`one.next().value`) là toàn bộ mảng `['a', 'b', 'c']`.\r\n\r\n```javascript\r\nconsole.log(one.next().value); \/\/ ['a', 'b', 'c']\r\nconsole.log(one.next().value); \/\/ undefined\r\n```\r\n\r\nTrong `generatorTwo`, ta sử dụng từ khóa `yield*`. Có nghĩa là giá trị đầu tiên mà `two` trả về là giá trị đầu tiên trong `iterator`. Trong trường hợp này `iterator` của chúng ta là mảng `['a', 'b', 'c']`. Giá trị đầu tiên của mảng là `a`, nên lần đầu tiên khi ta gọi `two.next().value`, `a` sẽ được trả về.\r\n\r\n```javascript\r\nconsole.log(two.next().value); \/\/ 'a'\r\nconsole.log(two.next().value); \/\/ 'b'\r\nconsole.log(two.next().value); \/\/ 'c'\r\nconsole.log(two.next().value); \/\/ undefined\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 113,
        "title": "Output là gì",
        "content": "```javascript\r\nconsole.log(`${((x) => x)(\"I love\")} to program`);\r\n```\r\n\r\n- A: `I love to program`\r\n- B: `undefined to program`\r\n- C: `${(x => x)('I love') to program`\r\n- D: `TypeError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nBiểu thức bên trong chuỗi template (tức chuỗi nằm trong hai dấu ``, gọi là `template literals`) sẽ được đánh giá trước. Sau đó kết quả của biểu thức sẽ được đưa vào chuỗi, trong trường hợp này biểu thức là `(x => x)('I love')`. Chúng ta truyền giá trị đối số `'I love'`cho một arrow function`x => x`. `x`lúc này là`'I love'`, và trả về chính nó. Cuối cùng kết quả của chuỗi là `I love to program`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 114,
        "title": "Điều gì sẽ xảy ra",
        "content": "```javascript\r\nlet config = {\r\n  alert: setInterval(() => {\r\n    console.log(\"Alert!\");\r\n  }, 1000),\r\n};\r\n\r\nconfig = null;\r\n```\r\n\r\n- A: Callback `setInterval` sẽ không được gọi\r\n- B: Callback `setInterval` sẽ được gọi một lần duy nhất\r\n- C: Callback `setInterval` vẫn sẽ được gọi mỗi giây một lần\r\n- D: `config.alert()` không bao giờ được gọi bởi config là `null`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nThông thường khi ta set một object bằng `null`, thì object này sẽ được bộ dọn rác dọn đi do không còn gì reference đến nó nữa (_garbage collected_). Tuy nhiên, do callback trong `setInterval` là một arrow function (do đó nó sẽ gắn với object `config`), nên callback này vẫn sẽ giữ reference đến object `config`. Vì vẫn còn giữ reference, nên object sẽ không bị dọn đi. Do đó nó vẫn sẽ được gọi sau mỗi 1000ms (tức 1 giây).\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 115,
        "title": "Những hàm nào sẽ trả về `'Hello world!'`",
        "content": "```javascript\r\nconst myMap = new Map();\r\nconst myFunc = () => \"greeting\";\r\n\r\nmyMap.set(myFunc, \"Hello world!\");\r\n\r\n\/\/1\r\nmyMap.get(\"greeting\");\r\n\/\/2\r\nmyMap.get(myFunc);\r\n\/\/3\r\nmyMap.get(() => \"greeting\");\r\n```\r\n\r\n- A: 1\r\n- B: 2\r\n- C: 2 và 3\r\n- D: Tất cả\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nKhi ta thêm vào một cặp key\/value với từ khóa `set`, key sẽ là đối số đầu tiên đưa vào trong hàm `set` function, và value sẽ là đối số thứ hai.Trong trường hơp này key chính là _hàm_ `() => 'greeting'`, value là `'Hello world'`. `myMap` trở thành `{ () => 'greeting' => 'Hello world!' }`.\r\n\r\n1 sai, vì key là `() => 'greeting'` chứ không phải là `'greeting'`.\r\n3 sai, vì khi chúng ta đưa một hàm vào làm đối số trong phương thức `get`, nó sẽ được đưa vào dưới dạng _reference_. Function vốn là object, do đó 2 hàm sẽ không bao giờ là `strictly equal`, mặc dù chúng có trông giống nhau đi chăng nữa thì chúng vẫn trỏ đến các vùng nhớ khác nhau.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 116,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia\",\r\n  age: 21,\r\n};\r\n\r\nconst changeAge = (x = { ...person }) => (x.age += 1);\r\nconst changeAgeAndName = (x = { ...person }) => {\r\n  x.age += 1;\r\n  x.name = \"Sarah\";\r\n};\r\n\r\nchangeAge(person);\r\nchangeAgeAndName();\r\n\r\nconsole.log(person);\r\n```\r\n\r\n- A: `{name: \"Sarah\", age: 22}`\r\n- B: `{name: \"Sarah\", age: 23}`\r\n- C: `{name: \"Lydia\", age: 22}`\r\n- D: `{name: \"Lydia\", age: 23}`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nCả hai hàm `changeAge` và `changeAgeAndName` đều có tham số mặc định - nó là một _bản copy_ mới của object `{ ...person }`. Object này sẽ copy tất cả những cặp key\/values bên trong object `person`.\r\n\r\nĐầu tiên, chúng ta gọi hàm `changeAge` và đưa chính object `person` vào làm đối số. Hàm này sẽ tăng giá trị của thuộc tính `age` lên 1. `person` lúc này là `{ name: \"Lydia\", age: 22 }`.\r\n\r\nSau đó, chúng ta gọi hàm `changeAgeAndName` tuy nhiên không đưa vào đối số nào cả. Do đó giá trị của `x` lúc này sẽ là giá trị mặc định, tức một bản _copy_ của object `{ ...person }`. Do nó chỉ là một bản copy (tức object mới), nên nó không ảnh hưởng gì tới giá trị của object `person` gốc, giá trị của `person` gốc sẽ vẫn là `{ name: \"Lydia\", age: 22 }`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 117,
        "title": "Phép tính nào dưới đây trả về `6`",
        "content": "```javascript\r\nfunction sumValues(x, y, z) {\r\n  return x + y + z;\r\n}\r\n```\r\n\r\n- A: `sumValues([...1, 2, 3])`\r\n- B: `sumValues([...[1, 2, 3]])`\r\n- C: `sumValues(...[1, 2, 3])`\r\n- D: `sumValues([1, 2, 3])`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới toán tử ba chấm (`spread operator`) `...`, chúng ta có thể unpack một iterable thành từng các phần tử riêng biệt. Hàm `sumValues` nhận vào 3 giá trị: `x`, `y` và `z`. `...[1, 2, 3]` sẽ trả về `1, 2, 3`, đưa vào `sumValues` sẽ cho ta kết quả là 6.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 118,
        "title": "Output là gì",
        "content": "```javascript\r\nlet num = 1;\r\nconst list = [\"🥳\", \"🤠\", \"🥰\", \"🤪\"];\r\n\r\nconsole.log(list[(num += 1)]);\r\n```\r\n\r\n- A: `🤠`\r\n- B: `🥰`\r\n- C: `SyntaxError`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới phép toán `+=`, Ta tăng giá trị của `num` lên `1`. `num` có giá trị khởi tạo là `1`, do đó `1 + 1` là `2`. Phần tử thứ hai của `list` là 🥰, do đó `console.log(list[2])` sẽ in ra 🥰.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 119,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  firstName: \"Lydia\",\r\n  lastName: \"Hallie\",\r\n  pet: {\r\n    name: \"Mara\",\r\n    breed: \"Dutch Tulip Hound\",\r\n  },\r\n  getFullName() {\r\n    return `${this.firstName} ${this.lastName}`;\r\n  },\r\n};\r\n\r\nconsole.log(person.pet",
        "answers": " Đáp án: B\r\n\r\nVới phép toán optional chaining `?.`, chúng ta sẽ không cần phải check xem giá trị phía sau nó có được phép truy cập hay có tồn tại hay không. Nếu ta cố lấy một thuộc tính của `undefined` hay `null` (_nullish_), biểu thức sẽ dừng lại và trả về `undefined`.\r\n\r\n`person.pet?.name`: `person` có thuộc tính `pet`: do đó `person.pet` không phải là một nullish. Nó có một thuộc tính `name`, với giá trị `Mara`.\r\n\r\n`person.pet?.family?.name`: `person` có thuộc tính `pet`: do đó `person.pet` không phải là nullish. Tuy nhiên `pet` không có thuộc tính `family`, nên `person.pet.family` là nullish. Biểu thức sẽ trả về `undefined`.\r\n\r\n`person.getFullName?.()`: `person` có thuộc tính `getFullName`: do đó `person.getFullName()` không phải nullish và có thể gọi ra, trả về `Lydia Hallie`.\r\n\r\n`member.getLastName?.()`: `member` không được định nghĩa: do đó `member.getLastName()` là nullish. Biểu thức trả về `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 120,
        "title": "Ouput là gì",
        "content": "```javascript\r\nconst groceries = [\"banana\", \"apple\", \"peanuts\"];\r\n\r\nif (groceries.indexOf(\"banana\")) {\r\n  console.log(\"We have to buy bananas!\");\r\n} else {\r\n  console.log(`We don't have to buy bananas!`);\r\n}\r\n```\r\n\r\n- A: We have to buy bananas!\r\n- B: We don't have to buy bananas\r\n- C: `undefined`\r\n- D: `1`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTa đưa một điều kiện `groceries.indexOf(\"banana\")` vào câu lệnh `if`. `groceries.indexOf(\"banana\")` trả về `0`, là một giá trị `falsy`. Do đó điệu kiện `if` sẽ chạy vào khối `else` và in ra `We don't have to buy bananas!`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 121,
        "title": "Ouput là gì",
        "content": "```javascript\r\nconst config = {\r\n  languages: [],\r\n  set language(lang) {\r\n    return this.languages.push(lang);\r\n  },\r\n};\r\n\r\nconsole.log(config.language);\r\n```\r\n\r\n- A: `function language(lang) { this.languages.push(lang }`\r\n- B: `0`\r\n- C: `[]`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nPhương thức `language` là một `setter`. Setter không mang giá trị, nhiệm vụ của nó chỉ đơn giản là _thay đổi_ thuộc tính. Khi ta gọi một phương thức `setter` nó sẽ trả về `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 122,
        "title": "Output là gì",
        "content": "```javascript\r\nconst name = \"Lydia Hallie\";\r\n\r\nconsole.log(!typeof name === \"object\");\r\nconsole.log(!typeof name === \"string\");\r\n```\r\n\r\n- A: `false` `true`\r\n- B: `true` `false`\r\n- C: `false` `false`\r\n- D: `true` `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\n`typeof name` trả về `\"string\"`. Chuỗi `\"string\"` là một giá trị `truthy`, do đó `!typeof name` sẽ trả về một giá trị bool là `false`. Do đó `false === \"object\"` và `false === \"string\"` đều trả về`false`.\r\n\r\n(Nếu chúng ta muốn check xem một kiểu dữ liệu không phải là một kiểu nào đó, chúng ta nên viết `!==` thay vì `!typeof`)\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 123,
        "title": "Output là gì",
        "content": "```javascript\r\nconst add = (x) => (y) => (z) => {\r\n  console.log(x, y, z);\r\n  return x + y + z;\r\n};\r\n\r\nadd(4)(5)(6);\r\n```\r\n\r\n- A: `4` `5` `6`\r\n- B: `6` `5` `4`\r\n- C: `4` `function` `function`\r\n- D: `undefined` `undefined` `6`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nHàm `add` trả về một arrow function, arrow function này lại trả về một arrow function khác, arrow function này lại trả về một arrow function khác nữa. Hàm đầu tiên nhận vào một tham số `x` với giá trị là 4 `4`. Chúng ta gọi hàm thứ hai, nhận vào giá trị của `y` là `5`. Sau đó chúng ta gọi hàm thứ 3, nhận vào giá trị của `z` là `6`. Sau đó ta truy cập các giá trị của `x`, `y` và `z` bên trong arrow function cuối cùng, khi này JS engine sẽ lần ngược lại scope chain để tìm các giá trị `x` và `y` tương ứng. Do đó cuối cùng nó sẽ trả về `4` `5` `6`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 124,
        "title": "Output là gì",
        "content": "```javascript\r\nasync function* range(start, end) {\r\n  for (let i = start; i  {\r\n  const gen = range(1, 3);\r\n  for await (const item of gen) {\r\n    console.log(item);\r\n  }\r\n})();\r\n```\r\n\r\n- A: `Promise {1}` `Promise {2}` `Promise {3}`\r\n- B: `Promise {}` `Promise {}` `Promise {}`\r\n- C: `1` `2` `3`\r\n- D: `undefined` `undefined` `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nGenerator `range` trả về một async object với các promise tương ứng với mỗi phần tử ta đưa vào: `Promise{1}`, `Promise{2}`, `Promise{3}`. Ta set giá trị `gen` bằng với một async object để thực hiện vòng lặp `for await ... of` sau đó. Tiếp đó ta lại set giá trị của `item` bằng với giá trị trả về của mỗi promise: đầu tiên là `Promise{1}`, sau đó `Promise{2}`, sau đó `Promise{3}`. Do chúng ta sử dụng cú pháp `async\/await` nên sẽ trả về giá trị đã được resolve của promise `item`, do đó lần lượt `1`, `2`, và `3` được in ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 125,
        "title": "Output là gì",
        "content": "```javascript\r\nconst myFunc = ({ x, y, z }) => {\r\n  console.log(x, y, z);\r\n};\r\n\r\nmyFunc(1, 2, 3);\r\n```\r\n\r\n- A: `1` `2` `3`\r\n- B: `{1: 1}` `{2: 2}` `{3: 3}`\r\n- C: `{ 1: undefined }` `undefined` `undefined`\r\n- D: `undefined` `undefined` `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\n`myFunc` nhận vào một object có các thuộc tính `x`, `y` và `z` làm đối số của nó. Do chúng ta đưa vào 3 số riêng biệt (1, 2, 3) chứ không phải một object với các thuộc tính `x`, `y`, `z` như ({x: 1, y: 2, z: 3}), nên `x`, `y`, `z` đều có giá trị là `undefined`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 126,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getFine(speed, amount) {\r\n  const formattedSpeed = new Intl.NumberFormat({\r\n    'en-US',\r\n    { style: 'unit', unit: 'mile-per-hour' }\r\n  }).format(speed)\r\n\r\n  const formattedAmount = new Intl.NumberFormat({\r\n    'en-US',\r\n    { style: 'currency', currency: 'USD' }\r\n  }).format(amount)\r\n\r\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`\r\n}\r\n\r\nconsole.log(getFine(130, 300))\r\n```\r\n\r\n- A: The driver drove 130 and has to pay 300\r\n- B: The driver drove 130 mph and has to pay \\$300.00\r\n- C: The driver drove undefined and has to pay undefined\r\n- D: The driver drove 130.00 and has to pay 300.00\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới phương thức `Intl.NumberFormat`, chúng ta có thể format bất cứ số nào theo định dạng ta mong muốn. Ở đây ta format giá trị `130` theo định dạng `en-US`, kiểu `unit`, đơn vị là `mile-per-hour`, và nó sẽ trả về `130 mph`. Tiếp theo số `300` sẽ được format theo định dạng `en-US`, kiểu `currentcy`, đơn vị `USD`, và kết quả là `$300.00`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 127,
        "title": "Output là gì",
        "content": "```javascript\r\nconst spookyItems = [\"👻\", \"🎃\", \"🕸\"];\r\n({ item: spookyItems[3] } = { item: \"💀\" });\r\n\r\nconsole.log(spookyItems);\r\n```\r\n\r\n- A: `[\"👻\", \"🎃\", \"🕸\"]`\r\n- B: `[\"👻\", \"🎃\", \"🕸\", \"💀\"]`\r\n- C: `[\"👻\", \"🎃\", \"🕸\", { item: \"💀\" }]`\r\n- D: `[\"👻\", \"🎃\", \"🕸\", \"[object Object]\"]`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nKhi tiến hành cú pháp destructuring object, chúng ta có thể unpack các giá trị ở phía phải của một object, và đưa giá trị đã được unpack đó làm giá trị của thuộc tính tương ứng của object phía trái. Trong trường hợp này, ta đã gán giá trị \"💀\" cho `spookyItems[3]`. Có nghĩa là mảng `spookyItems` đã bị thay đổi, chúng ta đã thêm vào nó một phần tử \"💀\". Do đó khi in ra thì kết quả sẽ là `[\"👻\", \"🎃\", \"🕸\", \"💀\"]` .\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 128,
        "title": "Output là gì",
        "content": "```javascript\r\nconst name = \"Lydia Hallie\";\r\nconst age = 21;\r\n\r\nconsole.log(Number.isNaN(name));\r\nconsole.log(Number.isNaN(age));\r\n\r\nconsole.log(isNaN(name));\r\nconsole.log(isNaN(age));\r\n```\r\n\r\n- A: `true` `false` `true` `false`\r\n- B: `true` `false` `false` `false`\r\n- C: `false` `false` `true` `false`\r\n- D: `false` `true` `false` `true`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới phương thức `Number.isNaN`, ta có thể check một giá trị có phải là _dạng số_ và bằng `NaN` hay không. `name` không phải là một số, do đó `Number.isNaN(name)` sẽ trả về `false`. `age` là một số, nhưng không bằng `NaN`, do đó `Number.isNaN(age)` cũng trả về `false`.\r\nVới phương thức `isNaN`, ta đơn thuần chỉ check xem giá trị đưa vào không phải là _dạng số_ hay không. `name` không phải là dạng số, nên `isNaN(name)` trả về `true`. `age` là số, nên `isNaN(age)` trả về `false`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 129,
        "title": "Output là gì",
        "content": "```javascript\r\nconst randomValue = 21;\r\n\r\nfunction getInfo() {\r\n  console.log(typeof randomValue);\r\n  const randomValue = \"Lydia Hallie\";\r\n}\r\n\r\ngetInfo();\r\n```\r\n\r\n- A: `\"number\"`\r\n- B: `\"string\"`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nMột biến được khai báo với từ khóa `const` sẽ không thể truy cập trước khi nó được khởi tạo: nó gọi là _temporal dead zone_. Trong hàm `getInfo`, giá trị `randomValue` sẽ được tìm kiếm đầu tiên trong scope của hàm `getInfo`. Tại dòng ta muốn lấy ra `typeof randomValue`, giá trị `randomValue` chưa được khởi tạo, do đó một `ReferenceError` sẽ được throw ra! Lưu ý nhỏ là Javascript engine sẽ không tìm kiếm ở scope khác nữa do `randomValue` đã được khai báo bên trong hàm `getInfo`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 130,
        "title": "Ouput là gì",
        "content": "```javascript\r\nconst myPromise = Promise.resolve(\"Woah some cool data\");\r\n\r\n(async () => {\r\n  try {\r\n    console.log(await myPromise);\r\n  } catch {\r\n    throw new Error(`Oops didn't work`);\r\n  } finally {\r\n    console.log(\"Oh finally!\");\r\n  }\r\n})();\r\n```\r\n\r\n- A: `Woah some cool data`\r\n- B: `Oh finally!`\r\n- C: `Woah some cool data` `Oh finally!`\r\n- D: `Oops didn't work` `Oh finally!`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nTrong khối `try`, ta in ra giá trị của biến `myPromise`: `\"Woah some cool data\"`. Do không có lỗi gì xảy ra ở đây cả, nên các lệnh trong khối `catch` sẽ không được chạy. Tuy nhiên các lệnh trong khối `finally` thì sẽ _luôn luôn_ chạy, nên `\"Oh finally!\"` sẽ được in ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 131,
        "title": "Output là gì",
        "content": "```javascript\r\nconst emojis = [\"🥑\", [\"✨\", \"✨\", [\"🍕\", \"🍕\"]]];\r\n\r\nconsole.log(emojis.flat(1));\r\n```\r\n\r\n- A: `['🥑', ['✨', '✨', ['🍕', '🍕']]]`\r\n- B: `['🥑', '✨', '✨', ['🍕', '🍕']]`\r\n- C: `['🥑', ['✨', '✨', '🍕', '🍕']]`\r\n- D: `['🥑', '✨', '✨', '🍕', '🍕']`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nVới phương thức `flat`, ta có thể tạo một mảng mới với các phần tử đã được `flattened` (làm phẳng). Độ sâu của mảng đã làm phẳng sẽ phụ thuộc vào giá trị ta đưa vào. Trong trường hợp này ta đưa vào là `1` (thực ra đây là giá trị default, ta không đưa vào cũng không sao), có nghĩa là chỉ những phần tử ở độ sâu 1 sẽ được làm phẳng. Chúng là`['🥑']` và `['✨', '✨', ['🍕', '🍕']]` trong trường hợp này. Nối lại ta sẽ có mảng mới `['🥑', '✨', '✨', ['🍕', '🍕']]`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 132,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Counter {\r\n  constructor() {\r\n    this.count = 0;\r\n  }\r\n\r\n  increment() {\r\n    this.count++;\r\n  }\r\n}\r\n\r\nconst counterOne = new Counter();\r\ncounterOne.increment();\r\ncounterOne.increment();\r\n\r\nconst counterTwo = counterOne;\r\ncounterTwo.increment();\r\n\r\nconsole.log(counterOne.count);\r\n```\r\n\r\n- A: `0`\r\n- B: `1`\r\n- C: `2`\r\n- D: `3`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\n`counterOne` là một instance của class `Counter`. Trong counter class có thuộc tính `count` bên trong constructor, và một phương thức `increment`. Đầu tiên chúng ta gọi phương thức `increment` hai lần bằng `counterOne.increment()`. Nên hiện tại giá trị của `counterOne.count` là `2`.\r\n\r\n\r\n\r\nSau đó chúng ta có thêm một biến mới là `counterTwo`, và set cho nó giá trị bằng với `counterOne`. Do object được tương tác bằng reference, nên việc này tương ứng với ta đã tạo thêm một reference đến bộ nhớ mà biến `counterOne` đã trỏ vào. Do chúng có chung bộ nhớ, bất cứ thay đổi nào trên `counterTwo` cũng sẽ thay đổi trên `counterOne`. Lúc này `counterTwo.count` cũng sẽ là `2`.\r\n\r\nTa gọi hàm `counterTwo.increment()` để tăng `count` lên `3`. Sau đó chúng ta in ra `count` ở `counterOne`, kết quả là `3`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 133,
        "title": "Output là gì",
        "content": "```javascript\r\nconst myPromise = Promise.resolve(Promise.resolve(\"Promise!\"));\r\n\r\nfunction funcOne() {\r\n  myPromise.then((res) => res).then((res) => console.log(res));\r\n  setTimeout(() => console.log(\"Timeout!\", 0));\r\n  console.log(\"Last line!\");\r\n}\r\n\r\nasync function funcTwo() {\r\n  const res = await myPromise;\r\n  console.log(await res);\r\n  setTimeout(() => console.log(\"Timeout!\", 0));\r\n  console.log(\"Last line!\");\r\n}\r\n\r\nfuncOne();\r\nfuncTwo();\r\n```\r\n\r\n- A: `Promise! Last line! Promise! Last line! Last line! Promise!`\r\n- B: `Last line! Timeout! Promise! Last line! Timeout! Promise!`\r\n- C: `Promise! Last line! Last line! Promise! Timeout! Timeout!`\r\n- D: `Last line! Promise! Promise! Last line! Timeout! Timeout!`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nĐầu tiên chúng ta gọi `funcOne`. Trong dòng đầu tiên của `funcOne`, chúng ta gọi `myPromise`, đây là một hàm _bất đồng bộ_. Trong khi chờ promise này hoàn thành, nó sẽ tiếp tục thực thi các dòng khác trong `funcOne`. Dòng tiếp theo là cũng là một hàm _bất đồng bộ_ `setTimeout`, phần callback của nó sẽ được gửi tới Web API (các bạn có thể tham khảo câu hỏi trước đó để hiểu về callstack và Web API).\r\n\r\nDo cả promise và timeout đều là những hàm xử lý bất đồng bộ, nên trong khi chờ chúng hoàn thành thì các dòng tiếp theo vẫn tiếp tục được thực thi. Có nghĩa là `Last line!` sẽ được in ra đầu tiên, do nó là một hàm chạy _đồng bộ_. Và đây cũng là dòng cuối cùng của hàm `funcOne`, khi này promise sẽ được resolve, trả về `Promise!`. Tuy nhiên do ta tiếp tục gọi hàm `funcTwo()`, call stack của ta vẫn chưa rỗng, nên callback của `setTimeout` vẫn chưa thể được đưa vào callstack (vẫn đang năm ở Web API).\r\n\r\nTrong hàm `funcTwo` đầu tiên ta sẽ _awaiting_ myPromise. Với từ khóa `await`, Ta sẽ tạm dừng thực thi cho tới khi n ào promise được resolved (hay rejected). Khi này ta sẽ in ra giá trị của `res` (do bản thân hàm promise lại trả về một promise). Nó sẽ in ra `Promise!`.\r\n\r\nDòng tiếp theo lại là một hàm _bất đồng bộ_ `setTimeout`, callback khi này tiếp tục được gửi tới Web API.\r\n\r\nTa tiếp tục thực thi dòng cuối cùng của `funcTwo`, trả về `Last line!`. Khi này `funcTwo` đã làm rỗng call stack. Các callback khi nãy (`() => console.log(\"Timeout!\")` từ `funcOne`, và `() => console.log(\"Timeout!\")` từ `funcTwo`) lần lượt được đưa vào trong call stack. Callback đầu tiên in ra `Timeout!`. Callback thứ hai in ra `Timeout!`. Kết quả cuối cùng sẽ là `Last line! Promise! Promise! Last line! Timeout! Timeout!`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 134,
        "title": "Làm thế nào có thể gọi hàm `sum` trong `index",
        "content": "`\r\n\r\n```javascript\r\n\/\/ sum.js\r\nexport default function sum(x) {\r\n  return x + x;\r\n}\r\n\r\n\/\/ index.js\r\nimport * as sum from \".\/sum\";\r\n```\r\n\r\n- A: `sum(4)`\r\n- B: `sum.sum(4)`\r\n- C: `sum.default(4)`\r\n- D: Default aren't imported with `*`, only named exports\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới dấu hoa thị `*`, ta sẽ import tất cả những gì đã được export ra bởi file đó, cả default lẫn những hàm có tên. Nếu ta có một dòng như sau:\r\n\r\n```javascript\r\n\/\/ info.js\r\nexport const name = \"Lydia\";\r\nexport const age = 21;\r\nexport default \"I love JavaScript\";\r\n\r\n\/\/ index.js\r\nimport * as info from \".\/info\";\r\nconsole.log(info);\r\n```\r\n\r\nThì kết quả sẽ là:\r\n\r\n```javascript\r\n{\r\n  default: \"I love JavaScript\",\r\n  name: \"Lydia\",\r\n  age: 21\r\n}\r\n```\r\n\r\nTrong ví dụ hàm `sum`, nó giống với chúng ta đã import hàm `sum` như thế này:\r\n\r\n```javascript\r\n{ default: function sum(x) { return x + x } }\r\n```\r\n\r\nTa có thể gọi hàm này bằng cách sử dụng `sum.default`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 135,
        "title": "Output là gì",
        "content": "```javascript\r\nconst handler = {\r\n  set: () => console.log(\"Added a new property!\"),\r\n  get: () => console.log(\"Accessed a property!\"),\r\n};\r\n\r\nconst person = new Proxy({}, handler);\r\n\r\nperson.name = \"Lydia\";\r\nperson.name;\r\n```\r\n\r\n- A: `Added a new property!`\r\n- B: `Accessed a property!`\r\n- C: `Added a new property!` `Accessed a property!`\r\n- D: Nothing gets logged\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nVới Proxy object, ta có thể add thêm được các hành vi (behavior) cho object bằng cách đưa nó vào làm đối số thứ hai. Trong trường hợp này, chúng ta đưa vào object `handler` có hai thuộc tính: `set` và `get`. `set` sẽ được gọi mỗi khi ta _thay đổi_ giá trị của thuộc tính, `get` sẽ được gọi mỗi khi ta _truy cập_ giá trị của thuộc tính.\r\n\r\nGiá trị của `person` sẽ là đối số đầu tiên đưa vào, là một object rỗng `{}`. Hành vi của `person` là đối số thứ hai, tức `handler`. Do đó môi khi ta thêm thuộc tính của obejct `person`, `set` sẽ được gọi. Nếu ta truy cập thuộc tính của `person` thì `get` sẽ được gọi.\r\n\r\nĐầu tiên ra thêm vào thuộc tính `name` cho proxy object (`person.name = \"Lydia\"`). `set` được gọi và in ra `\"Added a new property!\"`.\r\n\r\nSau đó chúng truy cập thuộc tính này, `get` được gọi và in ra `\"Accessed a property!\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 136,
        "title": "Cách nào sau đây sẽ thay đổi object `person`",
        "content": "```javascript\r\nconst person = { name: \"Lydia Hallie\" };\r\n\r\nObject.seal(person);\r\n```\r\n\r\n- A: `person.name = \"Evan Bacon\"`\r\n- B: `person.age = 21`\r\n- C: `delete person.name`\r\n- D: `Object.assign(person, { age: 21 })`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nVới `Object.seal` ta có thể ngăn _thêm vào_ các thuộc tính mới, hay _xóa đi_ các thuộc tính cũ.\r\n\r\nTuy nhiên ta vẫn có thể _thay đổi_ các thuộc tính cũ.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 137,
        "title": "Cách nào sau đây có thể thay đổi object `person`",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia Hallie\",\r\n  address: {\r\n    street: \"100 Main St\",\r\n  },\r\n};\r\n\r\nObject.freeze(person);\r\n```\r\n\r\n- A: `person.name = \"Evan Bacon\"`\r\n- B: `delete person.address`\r\n- C: `person.address.street = \"101 Main St\"`\r\n- D: `person.pet = { name: \"Mara\" }`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nPhương thức `Object.freeze` sẽ _đóng băng_ object. Ta không thể thêm\/sửa\/xóa bất kì thuộc tính nào.\r\n\r\nTuy nhiên trên thực tế đây chỉ là đóng băng _nông_ (_shallowly_) object, có nghĩa là nó chỉ đóng băng các thuộc tính _trực tiếp_ của object mà thôi. Nếu thuộc tính lại là một object khác, như `address` trong trường hợp này, thuộc tính bên trong của `address` sẽ không bị đóng băng, và ta vẫn có thể chỉnh sửa như bình thường.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 138,
        "title": "Output là gì",
        "content": "```javascript\r\nconst add = (x) => x + x;\r\n\r\nfunction myFunc(num = 2, value = add(num)) {\r\n  console.log(num, value);\r\n}\r\n\r\nmyFunc();\r\nmyFunc(3);\r\n```\r\n\r\n- A: `2` `4` and `3` `6`\r\n- B: `2` `NaN` and `3` `NaN`\r\n- C: `2` `Error` and `3` `6`\r\n- D: `2` `4` and `3` `Error`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nĐầu tiên, ta gọi hàm `myFunc()` nhưng không đưa vào đối số nào. Do đó `num` và `value` sẽ nhận các giá trị mặc định: `num` là `2`, và `value` sẽ là giá trị trả về của hàm `add`. Với hàm `add`, ta đưa `num` vào làm đối số, tức `2`. `add` trả về `4`, đây sẽ là giá trị của `value`.\r\n\r\nSau đó ta gọi hàm `myFunc(3)`, khi này `3` sẽ là giá trị của `num`. Ta không đưa vào giá trị cho `value`. Lúc này `value` tiếp tục nhận giá trị mặc định: giá trị trả về của hàm `add`. Trong `add`, ta đưa vào `num`, khi này là `3`. `add` sẽ trả về `6`, đây sẽ là giá trị của `value`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 139,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Counter {\r\n  #number = 10;\r\n\r\n  increment() {\r\n    this.#number++;\r\n  }\r\n\r\n  getNum() {\r\n    return this.#number;\r\n  }\r\n}\r\n\r\nconst counter = new Counter();\r\ncounter.increment();\r\n\r\nconsole.log(counter.#number);\r\n```\r\n\r\n- A: `10`\r\n- B: `11`\r\n- C: `undefined`\r\n- D: `SyntaxError`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nVới cú pháp ES2020, ta có thể thêm các thuộc tính private vào class bằng cách sử dụng `#`. Ta không thể truy cập được biến này bên ngoài class. Khi ta in ra `counter.#number`, một SyntaxError sẽ được throw: ta không thể truy cập từ phía ngoài class `Counter`!\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 140,
        "title": "Câu lệnh còn thiếu là gì",
        "content": "```javascript\r\nconst teams = [\r\n  { name: \"Team 1\", members: [\"Paul\", \"Lisa\"] },\r\n  { name: \"Team 2\", members: [\"Laura\", \"Tim\"] },\r\n];\r\n\r\nfunction* getMembers(members) {\r\n  for (let i = 0; i < members.length; i++) {\r\n    yield members[i];\r\n  }\r\n}\r\n\r\nfunction* getTeams(teams) {\r\n  for (let i = 0; i < teams.length; i++) {\r\n    \/\/ ✨ SOMETHING IS MISSING HERE ✨\r\n  }\r\n}\r\n\r\nconst obj = getTeams(teams);\r\nobj.next(); \/\/ { value: \"Paul\", done: false }\r\nobj.next(); \/\/ { value: \"Lisa\", done: false }\r\n```\r\n\r\n- A: `yield getMembers(teams[i].members)`\r\n- B: `yield* getMembers(teams[i].members)`\r\n- C: `return getMembers(teams[i].members)`\r\n- D: `return yield getMembers(teams[i].members)`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nTa duyệt và in ra giá trị của từng member bên trong `members`, mà `members` lại nằm bên trong mảng `teams`, ta cần đưa vào đối số `teams[i].members` cho hàm generator `getMembers` trong phần code thiếu. Hàm generator sẽ trả về một generator object. Để duyệt qua từng phần tử của một generator object, ta dùng từ khóa `yield*`.\r\n\r\nNếu ta dùng `yield`, `return yield`, hay `return`, toàn bộ generator sẽ được trả về trong lần đầu tiên chúng ta gọi phương thức `next`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 141,
        "title": "Output là gì",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia Hallie\",\r\n  hobbies: [\"coding\"],\r\n};\r\n\r\nfunction addHobby(hobby, hobbies = person.hobbies) {\r\n  hobbies.push(hobby);\r\n  return hobbies;\r\n}\r\n\r\naddHobby(\"running\", []);\r\naddHobby(\"dancing\");\r\naddHobby(\"baking\", person.hobbies);\r\n\r\nconsole.log(person.hobbies);\r\n```\r\n\r\n- A: `[\"coding\"]`\r\n- B: `[\"coding\", \"dancing\"]`\r\n- C: `[\"coding\", \"dancing\", \"baking\"]`\r\n- D: `[\"coding\", \"running\", \"dancing\", \"baking\"]`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nHàm `addHobby` nhận vào hai đối số, `hobby`, và `hobbies` với giá trị default là mảng `hobbies` của object `person`.\r\n\r\nĐầu tiên chúng ta gọi hàm `addHobby` và đưa vào `\"running\"` làm giá trị cho `hobby`, và một mảng rỗng cho `hobbies`. Do chúng ta đưa vào một mảng rỗng cho `hobbies`, `\"running\"` sẽ được add vào một mảng rỗng.\r\n\r\nSau đó chúng ta tiếp tục gọi hàm `addHobby`, đưa `\"dancing\"` vào làm giá trị cho `hobby`. Chúng ta không hề đưa vào giá trị nào cho `hobbies`, do đó nó sẽ sử dụng giá trị mặc định, tức mảng `hobbies` trong thuộc tính của object `person`. Có nghĩa là ta đã thêm `dancing` vào trong mảng `person.hobbies`.\r\n\r\nCuối cùng chúng ta lại gọi `addHobby`, đưa `\"baking\"` vào làm giá trị cho `hobby`, và mảng `person.hobbies` làm giá trị cho `hobbies`. Có nghĩa là ta đã thêm `baking` vào trong mảng `person.hobbies`.\r\n\r\nSau khi thêm `dancing` và `baking`, giá trị của `person.hobbies` là `[\"coding\", \"dancing\", \"baking\"]`\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 142,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Bird {\r\n  constructor() {\r\n    console.log(\"I'm a bird. 🦢\");\r\n  }\r\n}\r\n\r\nclass Flamingo extends Bird {\r\n  constructor() {\r\n    console.log(\"I'm pink. 🌸\");\r\n    super();\r\n  }\r\n}\r\n\r\nconst pet = new Flamingo();\r\n```\r\n\r\n- A: `I'm pink. 🌸`\r\n- B: `I'm pink. 🌸` `I'm a bird. 🦢`\r\n- C: `I'm a bird. 🦢` `I'm pink. 🌸`\r\n- D: Nothing, we didn't call any method\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nChúng ta tạo ra biến `pet` là một instance của clas `Flamingo`. Khi ta tạo ra instance, `constructor` bên trong `Flamingo` sẽ được gọi. Đầu tiên, `\"I'm pink. 🌸\"` được in ra, sau đó chúng ta gọi `super()`. `super()` sẽ gọi constructor ở class cha, tức `Bird`. Hàm constructor trong `Bird` được gọi và in ra `\"I'm a bird. 🦢\"`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 143,
        "title": "Câu lệnh nào sẽ bị lỗi",
        "content": "```javascript\r\nconst emojis = [\"🎄\", \"🎅🏼\", \"🎁\", \"⭐\"];\r\n\r\n\/* 1 *\/ emojis.push(\"🦌\");\r\n\/* 2 *\/ emojis.splice(0, 2);\r\n\/* 3 *\/ emojis = [...emojis, \"🥂\"];\r\n\/* 4 *\/ emojis.length = 0;\r\n```\r\n\r\n- A: 1\r\n- B: 1 and 2\r\n- C: 3 and 4\r\n- D: 3\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nTừ khóa `const` làm cho ta không thể _định nghĩa lại_ giá trị của biến, nó là _read-only_. Tuy nhiên giá trị của bên trong nó thì không phải là bất biến. Các thuộc tính bên trong mảng `emojis` vẫn có thể được sửa đổi, ví dụ thêm phần tử, cắt, hoặc là đưa độ dài mảng về 0.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 144,
        "title": "Ta cần thêm gì vào object `person` để khi gọi `[",
        "content": "```javascript\r\nconst person = {\r\n  name: \"Lydia Hallie\",\r\n  age: 21\r\n}\r\n\r\n[...person] \/\/ [\"Lydia Hallie\", 21]\r\n```\r\n\r\n- A: Nothing, object are iterable by default\r\n- B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }`\r\n- C: `*[Symbol.iterator]() { for (let x in this) yield* Object.values(this) }`\r\n- D: `*[Symbol.iterator]() { for (let x in this) yield this }`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nMặc định ta không thể duyệt qua được object. Trừ phi nó được cài đặt iterator protocol. Ta có thể cài đặt bằng cách thêm vào một iterator symbol `[Symbol.iterator]`, biến nó trở thành generator object (object có thể duyệt được), ví dụ `*[Symbol.iterator]() {}`.\r\n\r\nĐể generator này trả về được mảng các giá trị của các thuộc tính của object `person`, tức `Object.values` của object `person`, ta sẽ sử dụng cấu trúc `yield* Object.values(this)`.\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 145,
        "title": "Output là gì",
        "content": "```javascript\r\nlet count = 0;\r\nconst nums = [0, 1, 2, 3];\r\n\r\nnums.forEach((num) => {\r\n  if (num) count += 1;\r\n});\r\n\r\nconsole.log(count);\r\n```\r\n\r\n- A: 1\r\n- B: 2\r\n- C: 3\r\n- D: 4\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nCâu lệnh `if` trong vòng lập `forEach` kiểm tra giá trị của `num` là truthy hay falsy. Vì số đầu tiên trong mảng `nums` là `0`, giá trị falsy, code trong câu lệnh `if` sẽ không chạy. `count` chỉ tăng giá trị đối với 3 số còn lại trong mảng `nums`, `1`, `2` và `3`. Vì giá trị của `count` tăng thêm `1` trong 3 lần, giá trị của `count` sẽ là `3`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 146,
        "title": "Output là gì",
        "content": "```javascript\r\nfunction getFruit(fruits) {\r\n  console.log(fruits",
        "answers": " Đáp án: D\r\n\r\nPhép toán `?` cho phép ta truy cập giá trị bên trong của object. Chúng ta thử in ra phần tử có thứ tự là `1` trong mảng con với thứ tự là `1` trong mảng `fruits`. Nếu mảng con với thứ tự là `1` trong mảng `fruits` không tồn tại, nó sẽ trả về `undefined`. Nếu mảng con với thứ tự là `1` trong mảng `fruits` tồn tại, nhưng mảng con này không có phần tử nào mang thứ tự `1`, nó cũng sẽ trả về `undefined`.\r\n\r\nTrước tiên, chúng ta thử in ra phần tử thứ hai trong mảng con `['🍍']` của `[['🍊', '🍌'], ['🍍']]`. Mảng con này chỉ chứa một phần tử, nghĩa là không có phần tử nào với thứ tự là `1`, và trả về `undefined`.\r\n\r\nSau đó, ta gọi hàm `getFruits` khi không truyền vào một đối số nào, nghĩa là `fruits` có giá trị mặc định là `undefined`. Vì ta truyền phần tử mang thứ tự `1` của `fruits`, nó trả về `undefined` do phần tử này không tồn tại.\r\n\r\nCuối cùng, ta thử in ra phần tử thứ hai trong mảng con `['🍊', '🍌']` của mảng `['🍍'], ['🍊', '🍌']`. Phần tử mang thứ tự `1` bên trong mảng con này là `🍌` sẽ được in ra.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 147,
        "title": "Output là gì",
        "content": "```javascript\r\nclass Calc {\r\n  constructor() {\r\n    this.count = 0;\r\n  }\r\n\r\n  increase() {\r\n    this.count++;\r\n  }\r\n}\r\n\r\nconst calc = new Calc();\r\nnew Calc().increase();\r\n\r\nconsole.log(calc.count);\r\n```\r\n\r\n- A: `0`\r\n- B: `1`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nTa set biến `calc` bằng một instance mới của `Calc` class. Sau đó ta tạo ra instance mới của `Calc` và gọi `increase` hàm trên instance đó. Vì thuộc tính count nằm trong constructor của `Calc` class, thuộc tính count không được sử dụng trên prototype của `Calc`. Điều này nghĩa là giá trị của count chưa được thay đổi cho instance mà calc trỏ vào, giá trị của count vẫn là `0`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 148,
        "title": "Output là gi",
        "content": "```javascript\r\nconst user = {\r\n  email: \"e@mail.com\",\r\n  password: \"12345\",\r\n};\r\n\r\nconst updateUser = ({ email, password }) => {\r\n  if (email) {\r\n    Object.assign(user, { email });\r\n  }\r\n\r\n  if (password) {\r\n    user.password = password;\r\n  }\r\n\r\n  return user;\r\n};\r\n\r\nconst updatedUser = updateUser({ email: \"new@email.com\" });\r\n\r\nconsole.log(updatedUser === user);\r\n```\r\n\r\n- A: `false`\r\n- B: `true`\r\n- C: `TypeError`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nHàm `updateUser` thay đổi các giá trị của thuộc tính `email` và `password` của user, nếu các giá trị của chúng được truyền vào hàm sau và sau đó hàm trả về `user` object. Giá trị trả về của hàm `updateUser` là `user` object, tức là giá trị của updateUser là trỏ đến cùng một `user` object mà `user` trỏ vào. `updatedUser === user` bằng `true`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 149,
        "title": "Output là gi",
        "content": "```javascript\r\nconst fruit = [\"🍌\", \"🍊\", \"🍎\"];\r\n\r\nfruit.slice(0, 1);\r\nfruit.splice(0, 1);\r\nfruit.unshift(\"🍇\");\r\n\r\nconsole.log(fruit);\r\n```\r\n\r\n- A: `['🍌', '🍊', '🍎']`\r\n- B: `['🍊', '🍎']`\r\n- C: `['🍇', '🍊', '🍎']`\r\n- D: `['🍇', '🍌', '🍊', '🍎']`\r\n\r\nĐáp án",
        "answers": " Đáp án: C\r\n\r\nTrước tiên, ta gọi hàm `slice` trên mảng fruit. Hàm slice không thay đổi mảng ban đầu nhưng sẽ trả về giá trị mà nó cắt từ mảng đó: banana emoji. Sau đó ta gọi hàm `splice` trên mảng fruit. Hàm splice sẽ thay đổi mảng ban đầu, nghĩa là mảng fruit bây giờ sẽ bao gồm `['🍊', '🍎']`. Cuối cùng, ta gọi mảng `unshift` trên mảng `fruit` để thay đổi mảng ban đầu bằng cách cộng thêm giá trị được đưa ra, trong trường hợp này là ‘🍇’, phần tử đầu tiên của mảng. Mảng fruit bây giờ bao gồm ['🍇', '🍊', '🍎']`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 150,
        "title": "Output là gì",
        "content": "```javascript\r\nconst animals = {};\r\nlet dog = { emoji: \"🐶\" };\r\nlet cat = { emoji: \"🐈\" };\r\n\r\nanimals[dog] = { ...dog, name: \"Mara\" };\r\nanimals[cat] = { ...cat, name: \"Sara\" };\r\n\r\nconsole.log(animals[dog]);\r\n```\r\n\r\n- A: `{ emoji: \"🐶\", name: \"Mara\" }`\r\n- B: `{ emoji: \"🐈\", name: \"Sara\" }`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nCác keys của object được chuyển thành các chuỗi.\r\n\r\nDo giá trị của `dog` là một object, `animals[dog]` thực sự nghĩa là ta tạo ra một thuộc tính mới gọi là `\"object Object\"` bằng với object mới. `animals[\"object Object\"]` lúc này bằng với `{ emoji: \"🐶\", name: \"Mara\"}`.\r\n\r\n`cat` cũng là một object, nên `animals[cat]` thực sự nghĩa là ta thay đổi giá trị của ` animals[``\"``object Object``\"``] ` bằng thuộc tính cat mới.\r\n\r\nKhi in ra `animals[dog]`, hoặc thực chất là `animals[\"object Object\"]` vì thay `dog` object bằng một chuỗi thì nó trả về `\"object Object\"`, ta nhận được `{ emoji: \"🐈\", name: \"Sara\" }`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 151,
        "title": "Output là gì",
        "content": "```javascript\r\nconst user = {\r\n  email: \"my@email.com\",\r\n  updateEmail: (email) => {\r\n    this.email = email;\r\n  },\r\n};\r\n\r\nuser.updateEmail(\"new@email.com\");\r\nconsole.log(user.email);\r\n```\r\n\r\n- A: `my@email.com`\r\n- B: `new@email.com`\r\n- C: `undefined`\r\n- D: `ReferenceError`\r\n\r\nĐáp án",
        "answers": " Đáp án: A\r\n\r\nHàm `updateEmail` là một cú pháp arrow function và nó không gắn với `user` object. Điều này cho thấy từ khoá `this` không trỏ tới `user` object mà trỏ tới global scope. Giá trị của `email` trong `user` object không thay đổi. Khi ta in ra giá trị của `user.email`, nó trả về giá trị ban đầu của `my@email.com`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 152,
        "title": "Output là gì",
        "content": "```javascript\r\nconst promise1 = Promise.resolve(\"First\");\r\nconst promise2 = Promise.resolve(\"Second\");\r\nconst promise3 = Promise.reject(\"Third\");\r\nconst promise4 = Promise.resolve(\"Fourth\");\r\n\r\nconst runPromises = async () => {\r\n  const res1 = await Promise.all([promise1, promise2]);\r\n  const res2 = await Promise.all([promise3, promise4]);\r\n  return [res1, res2];\r\n};\r\n\r\nrunPromises()\r\n  .then((res) => console.log(res))\r\n  .catch((err) => console.log(err));\r\n```\r\n\r\n- A: `[['First', 'Second'], ['Fourth']]`\r\n- B: `[['First', 'Second'], ['Third', 'Fourth']]`\r\n- C: `[['First', 'Second']]`\r\n- D: `'Third'`\r\n\r\nĐáp án",
        "answers": " Đáp án: D\r\n\r\nHàm `Promise.all` trả về những promise truyền vào song song nhau. Nếu một promise thất bại, hàm `Promise.all` _rejects_ với giá trị của promise đó. Trong trường hợp này, `promise3` bị reject với giá trị `\"Third\"`. Ta đang kiểm tra giá trị bị reject trong chuỗi hàm `catch` khi goi hàm `runPromises` để tìm ra lỗi trong hàm `runPromises`. Chỉ có `\"Third\"` được trả về vì `promise3` reject giá trị này.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 153,
        "title": "Giá trị nào của `method` sẽ được trả về với log `{ name: \"Lydia\", age: 22 }`",
        "content": "```javascript\r\nconst keys = [\"name\", \"age\"];\r\nconst values = [\"Lydia\", 22];\r\n\r\nconst method =\r\n  \/*",
        "answers": " Đáp án: C\r\n\r\nHàm `fromEntries` trả về một mảng 2d trong một object. Phần tử đầu tiên trong từng mảng con sẽ là từ khoá và phần tử thứ hai trong từng mảng con sẽ là giá trị. Trong trường hợp này, ta tiến hành map qua mảng `keys`, nó sẽ trả về một mảng mà phần tử đầu tiên của mảng đó là phần tử trên thứ tự hiện tại của mảng key, và phần tử thứ hai của mảng đó là phần tử trên thứ tự hiện tại của mảng values.\r\n\r\nTheo như trên thì ta tạo ra một mảng gồm những mảng con chứa đựng những từ khoá và giá trị đúng, và nó trả về `{ name: \"Lydia\", age: 22 }`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 154,
        "title": "Output là gì",
        "content": "```javascript\r\nconst createMember = ({ email, address = {} }) => {\r\n  const validEmail = \/.+\\@.+\\..+\/.test(email);\r\n  if (!validEmail) throw new Error(\"Valid email pls\");\r\n\r\n  return {\r\n    email,\r\n    address: address",
        "answers": " Đáp án: C\r\n\r\nGiá trị mặc định của `address` là một object rỗng `{}`. Khi ta cho biến `member` bằng với object được trả về bởi hàm `createMember`, ta đã không truyền vào một giá trị của address, nghĩa là giá trị của address là object rỗng `{}` được mặc định. Object rỗng mang giá trị truthy, tức là điều kiện `address ? address : null` trả về `true`. Giá trị của address là một object rỗng `{}`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "index": 155,
        "title": "Output là gì",
        "content": "```javascript\r\nlet randomValue = { name: \"Lydia\" };\r\nrandomValue = 23;\r\n\r\nif (!typeof randomValue === \"string\") {\r\n  console.log(\"It's not a string!\");\r\n} else {\r\n  console.log(\"Yay it's a string!\");\r\n}\r\n```\r\n\r\n- A: `It's not a string!`\r\n- B: `Yay it's a string!`\r\n- C: `TypeError`\r\n- D: `undefined`\r\n\r\nĐáp án",
        "answers": " Đáp án: B\r\n\r\nĐiều kiện trong mệnh đề `if` kiểm tra xem giá trị của `!typeof randomValue` bằng với `\"string\"` hay không. Phép toán `!` chuyển giá trị đó thành giá trị boolean. Nếu giá trị là truthy, giá trị trả về sẽ là `false`, nếu giá trị là falsy, giá trị trả về sẽ là `true`. Trong trường hợp này, giá trị trả về của `typeof randomValue` là giá trị truthy `\"number\"`, nghĩa là giá trị của `!typeof randomValue` là một giá trị boolean `false`.\r\n\r\n`!typeof randomValue === \"string\"` luôn trả về false, vì ta thực sự đang kiểm tra `false === \"string\"`. Vì điều kiện đã trả về `false`, code của mệnh đề `else` sẽ chạy và `Yay it's a string!` được in ra.\r\n\r\n\r\n\r\n"
    }
]